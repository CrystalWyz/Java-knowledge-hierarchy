## 第二章 线程安全性

1. 要编写线程安全的代码，其核心在于要对状态，特别是对共享的和可变的状态的访问。
2. 从非正式的意义上来说，对象的状态是指存储在状态变量（例如实例或静态域）中的数据。对象的状态可能包括其他依赖对象的域。（对象在某个时间的快照）
3. “共享”意味着变量可以由多个线程同时访问，而“可变”则意味着变量的值在其生命周期内可以发送变化。
4. 一个对象是否需要是线程安全的，取决于他是否被多个线程访问。
5. 要使得对象是安全的，需要采用同步机制来协同对对象可变状态的访问。如果无法实现协同，那么可能会导致数据破坏以及其他不该出现的结果。
6. Java中主要的同步机制是关键字synchronized，它提供了一种独占的加锁方式，但“同步”这个术语还包括volatile类型的变量、显式锁以及原子变量。
7. 如果当多个线程访问同一个可变状态的变量时没有使用合适的同步，那么程序就会出现错误。有三种方式可以修复这个问题：
   1. 不在线程之间共享该状态变量。
   2. 将状态变量修改为不可变的变量。
   3. 在访问状态变量时使用同步。
8. 在编写并发应用程序时，一种正确的编程方法：首先使代码正确运行，然后再提高代码的速度。
9. 在线程安全性的定义中，最核心的概念就是正确性。正确性的含义就是，某个类的行为与其规范完全一致。衍生定义线程的安全性：当多个线程访问某个类时，这个类始终都能表现出正确的行为，那么就称这个类是线程安全的。（当多个线程访问某个类时，不管运行时环境采用何种调度方式或着这些线程将如何交替执行，并且在主调代码中不需要任何额外的同步或协同，这个类都能表现出正确的行为，那么就称这个类是线程安全的。
10. 方法中的变量存放于线程栈上的局部变量中，线程间的访问互不影响。
11. ++操作并不是原子的，它并不会作为一个不可分割的操作来执行。实际上，它包含了三个独立的操作：读取-累加-写入，即“读取-修改-写入”模型（一种竞态条件模型）。
12. 竞态条件：描述一个系统或者进程的输出依赖于不受控制的事件出现顺序或者出现时机。（想要获得正确的结果，取决于事件发生的时许）
13. 大多数竞态条件的本质——基于一种可能失效的观察结果来做出判断或执行某个计算。“检查—执行”模型：首先观察某个条件，然后根据这个观察结果采取相应的动作。但事实上在你观察到这个结果开始有所行动时，这个结果可能变得无效，从而导致各种问题。
14. 使用“检查—执行”的一种常见情况就是延迟初始化（懒加载）。延迟初始化的目的是将对象的初始化操作推迟到实际被使用时才进行，同时要确保只被初始化一次。
15. 数据竞争：如果在访问共享的非final类型的域时没有采用同步机制来进行协同，那么就会出现数据竞争。
16. “读取-修改-写入”模型 竞态条件：基于对象之前的状态来定义对象状态的转换。（解决方案：DCL）
17. 要避免竞态条件问题，就必须在某个线程修改该变量时，通过某种方式防止其他线程使用这个变量，从而确保其他线程只能在修改操作完成之前或之后读取和修改状态，而不是在修改状态的过程中。（加锁、原子类）
18. 原子操作是指，对于访问同一个状态的所有操作（包括该操作本身）来说，这个操作是一个原子方式执行的操作。（不可分、不可暂停）。
19. 复合操作：包含了一组必须以原子方式执行的操作以确保线程安全性。
20. 在java.util.concurrent.atomic包中包含了一些原子变量类，用于实现在数值和对象引用上的原子状态转换。通过用AtomicLong来代替long类型的计数器，能够确保所有对计数器状态的访问操作都是原子性的。
21. 当在无状态的类中添加一个状态时，如果状态完全由线程安全的对象来管理，那么这个类仍然是线程安全的。
22. 在实际情况中，应尽可能地使用现有的线程安全对象来管理类的状态。与非线程安全的对象相比，判断线程安全对象的可能状态以及其状态转换情况要更为容易。
23. 在线程安全性的定义中，多个线程之间的操作无论采用何种执行时序或交替方式，都要保证不变性条件不被破坏。（结果一致性）
24. 当在不变性条件中涉及多个变量时，各变量之间并不是彼此独立的，而是某个变量的值会对其他变量的值产生约束。因此，当更新某个变量时，需要在同一个原子操作中对其他变量同时进行更新（多个原子操作之间可以停顿，需要确保整体原子性）
25. 要保持状态的一致性，就需要在单个原子操作中更新所有相关的状态变量。
26. Java提供了一种内置的锁机制来支持原子性：同步代码块（synchronized）。同步代码块包括两个部分：一个座位锁对象的引用，一个座位由这个锁保护的代码块。以关键字synchronized来修饰的方法是一种横跨整个方法体的同步代码块，其中该同步代码块的锁就是方法调用所在的对象。静态方法以Class对象作为锁。
27. 每个Java对象都可以用作一个实现同步的锁，这些锁被称为内置锁或监视器锁。线程在进入同步代码块之前会自动获得锁，并且在推出同步代码块时自动释放锁，而无论是通过正常的控制路径推出，还是通过代码块中抛出异常退出。获得内置锁的唯一途径就是进入由这个锁保护的同步代码块或方法。
28. Java的内置锁相当于一种互斥体（互斥锁），这意味着最多只有一个线程能持有这种锁。当线程A尝试获取一个由线程B持有的锁时，线程A必须等待或者阻塞，知道线程B释放这个锁。如果B永远不释放锁，那么A也将永远地等待下去。
29. 由于每次只能有一个线程执行内置锁保护的代码块，因此，由这个锁保护的同步代码块会以原子的方式执行，多个线程在执行该代码块时也不会相互干扰。并发环境中的原子性与事物应用程序中的原子性有着相同的含义——一组语句作为一个不可分割的单元被执行。任何一个执行同步代码块的线程，都不可能看到有其他线程正在执行由同一个锁保护的同步代码块。
30. 内置锁是可重入的，因此如果某个线程试图获得一个已经由它自己持有的锁，那么这个请求就会成功。“重入”意味着获取锁的操作的粒度是“线程”，而不是“调用”。（Java中获取锁的操作力度是线程，而不是调用，即一个线程中多个加锁方法可以互相调用）。
31. 重入的一种实现方法是，为每个锁关联一个获取记数值和一个所有者线程。当计数值为0时，这个锁就被认为是没有被任何线程持有的。当线程请求一个未被持有的锁时，JVM将记下锁的持有者，并且将获取计数值置为1。如果同一个线程再次获取这个锁，计数值将递增，而当线程退出同步代码块时，计数器会相应地递减。当计数值为0时，这个锁将被释放。
32. 锁能使其保护的代码路径以串行形式来访问，因此可以通过锁来构造一些协议以实现对共享状态的独占访问。
33. 如果在复合操作的执行过程中有一个锁，那么会使复合操作成为原子操作。如果用同步来协调对某个变量的访问，那么在访问这个变量的所有位置上都要使用同步，而去，当使用锁来协调对某个变量的访问时，在访问变量的所有位置上都要使用同一个锁。
34. 对于可能被多个线程同时访问的可变状态的变量，在访问它时都需要持有同一个锁，在这种情况下，我们称状态变量时由这个锁保护的。
35. 当获取与对象相关联的锁时，并不能阻止其他线程访问该对象，某个线程在获得对象的锁之后，只能阻止其他线程获得同一个锁。
36. 每个共享的和可变的变量应该只由一个锁来保护，从而使维护人员知道时哪一个锁。
37. 一种常见的加锁约定是，将所有的可变状态都封装在对象内部，并通过对象的内置锁对所有访问可变状态的代码路径进行同步，使得在该对象上不会发生并发访问。
38. 当某个变量由锁来保护时，意味着在每次访问这个变量时都需要首先获得锁，这样就确保在同一时刻只有一个线程可以访问这个变量。
39. 当类的不可变性条件涉及多个状态变量时，那么还有另外一个需求：在不变性条件中的每个变量都必须由同一个锁来保护。
40. 对于每个包含多个变量的不变性条件，其中涉及的所有变量都需要由同一个锁来保护。
41. 不良并发应用程序：可同时调用的数量，不仅收到可用处理资源的限制，还收到应用程序本身结构的限制。
42. 同时用两种不同的同步机制不仅会带来混乱，也不会在性能或安全性上带来任何好处。
43. 通常，在简单性与性能之间存在相互制约的因素。当实现某个同步策略时，一定不要盲目地为了性能而牺牲简单性。
44. 当执行时间较长的计算活着可能无法快速完成的操作时，一定不要加锁。
