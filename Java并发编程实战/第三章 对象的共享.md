## 第三章 对象的共享

1. 可见性：当一个线程修改了对象的状态后，其他线程能够看到发生的状态变化。为了确保多个线程之间对内存写入操作的可见性，必须使用同步机制（每个线程拥有自己管理的线程本地缓存，写入操作首先写入本地缓存，再由同步操作刷新到公共内存。
2. 重排序：指令重拍，即计算机执行时并非完全按照从上到下依次执行。原则：最终一致性（单线程）。
3. 在没有同步的情况下，编译器、处理器和运行时都可能对操作的执行顺序进行一些意想不到的调整。
4. 只要有数据在多个线程之间共享，就使用正确的同步。
5. 当线程在没有同步的情况下读取变量时，可能会得到一个失效值，但至少这个值时由之前某个线程设置的值，而不是一个随机值。这种安全性保证也被称为最低安全性。
6. 最低安全性适用于绝大多数变量，但是存在一个例外：非volatile类型的64位数值变量（long和double）。Java内存模型要求，变量的读取操作和写入操作都必须时原子操作，但对于非volatile类型的long和double变量，JVM允许将64位的读操作或写操作分解为两个32位操作。
7. 在多线程中对于共享的long和double，最好使用volatile声明，它们的读写操作都不是原子操作。
8. 当线程B执行由锁保护的同步代码块时，可以看到线程A之前在同一把锁保护的同步代码块的所有操作结果。
9. 加锁的含义不仅仅局限于互斥行为，还包括内存的可见性。未来确保所有线程都能看到共享变量的最新值，所有执行读操作或者写操作的线程都必须在同一个锁上同步。
10. volatile变量用来确保将变量的更新操作通知到其他线程。当把变量声明为volatile类型后，编译器与运行时都会注意到这个变量是共享的，因此不会将该变量上的操作与其他内存操作一起重排序（禁止指令重排）。volatile变量不会被缓存在寄存器或者对其他处理器不可见的地方，因此在读取volatile变量时总是会返回最新写入的值。（线程可见性）
11. 访问volatile变量时不会执行加锁操作，因此也将不会执行线程阻塞。因此volatile变量是一种比synchronized关键字更轻量级的同步机制。
12. 不建议过度依赖volatile变量提供的可见性。如果在代码中依赖volatile变量来控制状态可见性，通常比使用锁代码更脆弱，也更难以理解。读取volatile变量的开销只比读取非volatile变量的开销略高。
13. 仅当volatile变量能简化代码的实现以及对同步策略的验证时，才应该使用它们。
14. 调试小提示：对于服务器应用程序，无论在开发阶段还是在测试阶段，当启动JVM时一定要指定-server命令行选项。server模式的JVM比client模式的JVM进行更多的优化。
15. volatile的语义不足以确保原子性操作。
16. 加锁机制及科研确保可见性又可以确保原子性，而volatile变量只能保证可见性。
17. 当且仅当满足以下所有条件时才应该使用volatile变量：
    1. 对变量的写入操作不依赖变量的当前值，或者你能确保只有单个线程更新变量的值。
    2. 该变量不会与其他状态变量一起纳入不变性条件中。
    3. 在访问变量时不需要加锁。
18. “发布”一个对象的意思是指：使对象能够在当前作用域之外的代码中使用。当某个不应该发布的对象被发布时，这种情况就被称为逸出。
19. 发布对象的最简单方法是将对象的引用保存到一个公有的静态变量中，以便任何类和线程都能看见该对象。
20. 当发布某个对象时，可能会间接地发布其他对象。当发布一个对象时，在该对象的非私有域中引用的所有对象同样会被发布。
21. 外部方法：指行为不完全由自己来规定的方法，包括其他类中定义的方法（继承 or 实现） 以及本身可以被改写的方法（既不是private方法也不是final方法）。当把一个对象传递给某个外部方法时，就相当于发布了这个对象。
22. 最后一种发布对象或其内部状态的机制就是发布一个内部的类实例。（xxx.this可以无条件访问外部对象）
23. this引用可以在构造函数中逸出。当且仅当对象的构造函数返回时，对象才处于可预测的和一致的状态。如果this引用在构造过程中逸出，那么这种对象就被认为是不正确构造。
24. 在构造过程中使用this引用逸出的一个常见错误是，在构造函数中启动一个线程。当对象在其构造函数中创建一个线程时，无论是显式创建还是隐式创建，this引用都会被新创建的线程共享。在对象为晚期构造之前，新的线程就可以看见它。在构造函数中创建线程并没有错误，但最好不要立即启动它，而是通过一个start或initialize方法来启动。
25. 在构造函数中调用一个可改写的实例方法时，同样会导致this引用在构造函数中逸出。
26. 如果想在构造函数中注册一个事件监听器或启动线程，那么可以使用一个私有的构造函数和一个公共的工厂方法，从而避免不正确的构造过程。
27. 线程封闭：不共享数据。实现线程安全的最简单方式。当某个对象封闭在一个线程中时，这种用法将自动实现线程安全性，即使被封闭的对象本身不是线程安全的。
28. Ad-hoc线程封闭是指，维护线程封闭性的职责完全由程序实现来承担。
29. 在volatile变量上存在一种特殊的线程封闭。只要你能确保只有单个线程对共享的volatile变量执行写入操作，那么就可以安全地在这些共享的volatile变量上执行“读取-修改-写入”操作。在这种情况下，相当于将修改操作封闭在单个线程中以防止竞态条件，并且volatile变量的可见性保证还确保了其他线程能看到最新的值。
30. 栈封闭是线程封闭的一种特例，在栈封闭种，只能通过局部变量才能访问对象。正如封装能使得代码更容易维持不变性条件那样，局部变量也能使对象更易于封闭在线程中。局部变量的固有属性之一就是封闭在执行线程中。它们位于执行线程的栈中，其他线程无法访问这个栈。
31. 任何方法都无法获得对基本类型的引用，因此Java语言的这种语义就确保来基本类型的局部变量始终封闭在线程内。
32. 如果在线程内部上下文中使用了非线程安全的对象，那么该对象仍然是线程安全的。
33. ThreadLocal类：保存线程本地对象，避免线程间共享。
34. 维持线程封闭性的一种更为规范的方法是使用ThreadLocal，这个类能使线程中的某个值与保存值的对象关联起来。ThreadLocal提供了get和set等访问接口或方法，这些方法为每个使用该变量的线程都存有一份独立的副本，因此get总是返回由当前执行线程在调用set时设置的最新值。
35. ThreadLocal对象通常用于防止对可变的单例对象或全局变量进行共享。
36. 当某个线程初次调用ThreadLocal.get()方法时，就会调用initialValue来获取初始值。这些特定于线程的值保存在Thread对象中，当线程终止后，这些值会作为垃圾回收。
37. 满足同步需求的另一种方法是使用不可变对象。如果某个对象在创建后其状态不可被改变，那么这个对象就被称为不可变对象。
38. 不可变对象不等于将对象中所有的域都声明为final类型，即使对象中所有的域都是final类型的，这个对象也仍然是可变的，因为在final类型的域中可以保存对可变对象的引用。
39. 当满足以下条件时，对象才是不可变的：
    1. 对象创建后其状态就不能修改。
    2. 对象的所有域都是final类型。
    3. 对象是正确创建的。
40. 在“不可变对象”与“不可变对象的引用”之间存在差异。保存在不可变对象中的程序状态仍然可以更新，即通过将一个保存新状态的实例来替换原有的不可变对象。（参考String）
41. 关键字final用于构造不可变性对象。final类型的域是不能修改的（但如果final域所引用的对象是可变的，那么这些被引用的对象是可以修改的）。final域能确保初始化过程的安全性，从而可以不受限制地访问不可变对象，并在共享这些对象时无须同步。
42. 在某些情况下，不可变对象能提供一种弱形式的原子性。
43. 每当需要一组相关数据以原子方式执行某个操作时，就可以考虑创建一个不可变的类来包含这些数据。
44. 对于在访问和更新多个相关变量出现的竞争条件问题，可以通过将这些变量全部保存在一个不可变对象中来消除。如果是一个可变对象，那么就必须使用锁来确保原子性。如果是一个不可变对象，那么当线程获得了该对象的引用后，就不必担心另外一个线程会修改对象的状态。如果要更新这些变量，那么可以创建一个新的容器对象，但其他使用原有对象的线程仍然会看到对象处于一致的状态。
45. Java内存模型为不可变对象的共享提供了一种特殊的初始化安全性保证。
46. 任何线程都可以在不需要额外同步的情况下安全地访问不可变对象，即使在发布这些对象时没有使用同步。
47. 要安全地发布一个对象，对象的引用以及对象的状态必须同时对其他线程可见。一个正确构造的对象可以通过以下几种方式来安全的发布：
    1. 在静态初始化函数中初始化一个对象的引用。
    2. 将对象的引用保存到volatile类型的域或者AtomicReferance对象中。
    3. 将对象的引用保存到某个正确构造对象的final类型的域中。
    4. 将对象的引用保存到一个由锁保护的域中。
48. 线程安全库中的容器类提供了以下的安全发布保证：
    1. 通过将一个键和值放入Hashtable、synchronizedMap或者ConcurrentMap中，可以安全地将它发布给任何从这些容器中访问它的线程。
    2. 通过将某个元素放入Vector、CopyOnWriteArrayList、CopyOnWriteArraySet、synchronizedList或synchronizedSet中，可以将该元素安全地发布到任何从这些容器中访问该元素的线程。
    3. 通过将某个元素放入BlockingQueue或者ConcurrentLinkedQueue中，可以将该元素安全地发布到任何从这些队列中访问该元素的线程。
49. 通常，要发布一个静态构造的对象，最简单和最安全的方式是使用静态的初始化器。
50. 静态初始化器由JVM在类的初始化阶段执行。由于在JVM内部存在同步机制，因此通过这种方式初始化的任何对象都可以被安全地发布。
51. 所有的安全发布机制都能确保，当对象的引用对所有访问该对象的线程可见时，对象发布的状态对于所有县也将是可见的。
52. 如果对象从技术上来看是可变的，但其状态在发布后不会再改变，那么把这种对象称为“事实不可变对象”。
53. 如果对象在构造后可以修改，那么安全发布只能确保“发布当时”状态的可见性。对于可变对象，不仅在发布对象时需要使用同步，而去在每次对象访问时同样需要使用同步来确保后续操作的可见性。
54. 对象的发布需求取决于它的可变性：
    1. 不可变对象可以通过任意的机制来发布。
    2. 事实不可变对象必须通过安全方式来发布。
    3. 可变对象必须通过安全方式来发布，并且必须是线程安全的活着由某个锁保护起来。
55. 在并发程序中使用和共享对象时，可以使用一些实用的策略，包括：
    1. 线程封闭：线程封闭的对象只能由一个线程拥有，对象被封闭在该线程中，并且只能由这个线程修改。
    2. 只读共享：在没有额外同步的情况下，。共享的只读对象可以由多个线程并发访问，但任何线程都不能修改它。共享的只读对象包括不可变对象和事实不可变对象。
    3. 线程安全共享。线程安全的对象在其内部实现同步，因此多个线程可以通过对象的公有接口来进行访问而不需要进一步的同步。
    4. 保护对象。被保护的对象只能通过特定的锁来访问。保护对象包括封装在其他线程安全对象中的对象，以及已发布的并且由某个特定锁保护的对象。