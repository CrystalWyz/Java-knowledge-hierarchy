## 第七章 取消与关闭

1. 中断，线程见的协作机制，被中断线程可以是否选择响应。
2. 如果外部代码能在某个操作正常完成之前将其置入“完成”状态，那么这个操作就就可以称为可取消的。
3. 在Java中没有一种安全的抢占方式方法来停止线程，因此也就没有安全的抢占式方法来停止任务。（在Java中，一个线程无法强制停止另一个线程）
4. 一个可取消的任务必须拥有取消策略，在这个策略中将详细地定义取消操作的“How”、“When”以及“What”，即其他代码如何请求取消该任务，任务在何时检查是否已经请求了取消，以及在响应取消请求时应该执行哪些操作。（其他线程发出取消信号，取消行为由执行线程自己抉择）
5. 若执行线程阻塞，则无法检查标志。
6. 线程中断是一种协作机制，线程可以通过这种机制来通知另一个线程，告诉它在合适的或者可能的情况下停止当前工作，并转而执行其他的工作。
7. 在Java的API规范中，并没有将中断与任何取消语义关联起来，但实际上，如果在取消之外的其他操作中使用中断，那么都是不合适的，并且很难支撑起更大的应用。
8. 每个线程都有一个boolean类型的中断状态。当中断线程时，这个线程的中断状态将被设置为true。在Thread中包含了中断线程以及查询线程中断状态的方法。
9. interrupt方法能中断目标线程，而isInterrupted方法能返回目标线程的中断状态。静态的interrupted方法将清除当前线程的中断状态，并返回它之前的值，这也是清除中断状态的唯一方法。
10. 阻塞库方法都会检查线程何时中断，并且在发现中断时提前返回。它们在响应中断时执行的操作包括：清除中断状态，抛出InterruptedException，表示阻塞操作由于中断而提前结束。JVM并不能保证阻塞方法检测到中断的速度，但在实际情况中响应速度还是非常快的
11. 调用interrupt并不意外着立即停止目标线程正在进行的工作，而只是传递来请求中断的消息。
12. 对中断操作的正确理解是：它并不会真正地中断一个正在运行的线程，而只是发出中断请求，然后由线程在下一个合适的时刻中断自己。
13. 在使用静态的interrupted时应该小心，因为它会清除当前线程的中断状态。如果在调用interrupted时返回了true，那么除非你想屏蔽这个中断，否则必须对它进行处理——可以抛出InterruptedException，或者通过再次调用interrupt来回复中断状态。
14. 通常，中断是实现取消的最合理方式。
15. 最合理的中断策略是某种形式的线程级取消操作或服务级取消操作：尽快退出，在必要时进行清理，通知某个所有者该线程已经退出。
16. 区分任务和线程对中断的反应是很重要的！线程应该只能由其所有者中断，任务只需要负责自己的中断，而不需要去负责线程的中断。只有实现了线程中断策略的代码才可以屏蔽中断请求。
17. 对于非线程所有者的代码来说，应该小心地保存中断状态。这样拥有线程的代码才能对中断作出响应，即使“非所有者”代码也可以做出响应（即非线程所有者代码可以不响应中断，但不要清除中断状态）
18. 当检查到中断请求时，任务并不需要放弃所有的操作——它可以推迟处理中断请求，并直到某个更合适的时刻。
19. 任务不应该对执行该任务的线程的中断策略做出任何假设，除非该任务被专门设计为在服务中运行，并且在这些服务中包含了特定的中断策略。
20. 对于一些不支持取消但仍可以调用中断阻塞方法的操作，它们必须在循环中调用这些方法，并在发现中断后重新尝试。在这种情况下，它们应该在本地保存中断状态，并在返回前恢复状态而不是在捕获InterruptedException时恢复状态。
21. ExecutorService.submit将返回一个Future来描述任务。Future拥有一个cancel方法，该方法带有一个boolean类型的参数mayInterruptIfRunning，表示取消操作是否成功。如果mayInterruptIfRunning为true并且任务当前正在某个线程中运行，那么这个线程能被中断。如果这个参数为false，那么意味着“若任务还没有启动，就不要运行它”，这种方式应该用于那些不处理中断的任务中。
22. 如果任务在标准的Executor中运行，并通过它们的Future来取消任务，那么可以设置mayInterruptIfRunning。当尝试取消某个任务时，不宜直接中断线程池，因为你并不知道中断请求到达时正在运行什么任务——只能通过任务的Future来实现取消。这也是在编写任务时要将中断视为一个取消请求的另一个理由：可以通过任务的Future来取消它们。（取消一个已完成的任务不会带来任何影响）
23. 如果一个线程由于执行同步的Socket I/O或者等待获得内置锁而阻塞，那么中断请求只能设置线程的中断状态，除此之外没有其他任何作用。对于那些由于执行不可中断操作而被阻塞的线程，可以使用类似于中断的手段来停止这些线程，但这要求我们必须知道线程阻塞的原因。
24. 通过重写interrupt()实现非标准中断
25. newTaskFor是Java 6 在ThreadPoolExecutor中新增的功能，newTaskFor是一个工厂方法，它将创建Future来代表任务。newTaskFor还能返回一个RunnableFuture接口，该接口扩展了Future和Runnable。
26. 正确的封装原则：除非拥有某个线程，否则不能对该线程进行操控。（由线程的所有者决定如何结束线程）线程的所有权是不可传递的：应用程序可以拥有服务，服务也可以拥有工作者线程，但应用程序不能拥有工作者线程。
27. 向printWriter这样的字符流类是线程安全的。
28. 如果需要在单条日志消息中写入多行，那么要通过客户端加锁来避免多个线程不正确地交错输出。（将日志操作设计为原子操作）
29. 在进行强行关闭时，shutdownNow首先关闭当前正在执行的任务，然后返回所有尚未启动的任务清单。（将线程池生命周期管理交给持有的服务）
30. 两种关闭方式的差别在于各自的安全性和响应性：强行关闭的速度要更快，但风险也更大，因为任务和可能在执行到一半时被结束；而正常关闭虽然速度慢，但却更安全，因为ExecutorService会一直等待到队列中的所有任务都执行完成后关闭。
31. 另一种关闭生产者——消费者服务的方式就是使用“毒丸”对象：“毒丸”对象是指一个放在队列上的对象，其含义是：“当得到这个对象时，立即停止。”只有在生产者和消费者的数量都已知的情况下，才可以使用“毒丸”对象。只有在无界队列中，“毒丸”对象才能可靠地工作。（每个生产者放一个表示生产完毕）
32. shutdownNow的局限性：丢失已经开始但尚未完成的任务。
33. 导致线程提前死亡的主要原因就是RunntimeException。
34. 在任务处理线程的生命周期中，将通过某种抽象机制来调用许多未知的代码，我们应该对在这些线程中执行的代码能否表现出正确的行为保持怀疑。（对调用的未知代码保持怀疑，为避免异常结束，需要catch未知代码）
35. 在Thread API中提供了UncaughtExceptionHandler，它能检测出某个线程由于未捕获的异常而终结的情况。
36. 当一个线程由于未捕获异常而退出时，JVM会把这个事件报告给应用程序提供的UncaughtExceptionHandler异常处理器。如果没有提供任何异常处理器，那么默认的行为是将栈追踪信息输出到System.error。
37. 在运行时间较长的应用程序中，通常会为所有线程的未捕获异常指定同一个异常处理器，并且该处理器至少会将异常信息记录到日志中。
38. 要为线程池中的所有线程设置一个UncaughtExceptionHandler，需要为ThreadPoolExecutor的构造函数提供一个ThreadFactory。
39. 标准线程池运行当发生未捕获异常时结束线程，但由于使用了一个try-finally代码块来接收通知，因此当线程结束时，将有新的线程来代替它。如果你希望在任务由于发生异常而失败时获得通知，并且执行一些特定于任务的恢复操作，那么可以将任务封装在能捕获异常的Runnable或Callable中，或者改写ThreadPoolExecutor的afterExecute方法。
40. 只有通过execute提交的任务，才能将它抛出的异常交给未捕获异常处理器，而通过submit提交的任务，无论是抛出的未检查异常，都将被认为是任务返回状态的一部分。如果一个由submit提交的任务由于抛出了异常而结束，那么这个异常将被Future.get封装在ExceptionException中重新抛出。
41. 在正常关闭中，JVM首先调用所有已注册的关闭钩子。关闭钩子是指通过Runtime.addShutdownHool注册的尚未开始的线程。JVM并不能保证关闭钩子的调用顺序。在关闭应用程序线程时，如果有线程仍然在运行，那么这些线程接下来将与关闭线程并发执行。当所有的关闭钩子都执行结束时，如果runFinalizersOnExit为true，那么JVM将运行终结器，然后再停止。JVM并不会停止或者中断任何在关闭时仍然运行的应用程序（关闭过程中可并行）。当JVM最终结束时，这些线程将被强行结束。如果关闭钩子或终结器没有执行完成，那么正常关闭进程“挂起”并且JVM必须背强行关闭。当被强行关闭时，只是关闭JVM，而不会运行关闭钩子。
42. 关闭钩子应该是线程安全的：不应该对应用程序的状态或者JVM的关闭原因做出任何假设。关闭钩子必须尽快退出，可以用于实现服务或应用程序的清理工作。
43. 线程可以分为两种：普通线程和守护线程。在JCM启动时创建的所有线程中，除了主线程以外，其他的线程都是守护线程（例如垃圾回收线程以及在执行其他辅助工作的线程）。当创建一个新线程时，新线程将继承创建它的线程的守护状态，因此在默认情况下，主线程创建的所有线程都是普通线程。
44. 普通线程与守护线程之间的差异仅在于当线程退出时发生的操作。当一个线程退出时，JVM会检查其他正在运行的线程，如果这些线程都是守护线程，那么JVM会正常退出操作。当JVM停止时，所有仍然存在的守护线程都将被抛弃——既不会执行finally代码块，也不会执行回卷栈，而JVM只是直接退出。