## 第十章 避免活跃性危险

1. 抱死：两个线程持有自己的锁并等待对方的锁。多个线程由于存在环路的锁依赖关系而永远地等待下去。
2. 当数据库检测到一组事物发生了死锁时，将选择一个牺牲者放弃这个事务并释放资源。
3. 当一组Java线程发生了死锁时，“游戏”将到此结束——这些线程永远不能再使用了。恢复应用程序的唯一方式就是终止并重启它，并希望不要再发生同样的事情
4. 锁顺序死锁：多线程以不同的顺序尝试获取相同的锁。如果所有线程以固定的顺序来获得锁，那么在程序中就不会出现锁顺序死锁问题。
5. 在制定锁的顺序时，可以使用System.identityHashCode方法，该方法将返回由Object.hashCode返回的值。首先获得这个“加时赛”锁，从而保证每次只有一个线程以未知的顺序获得这两个锁，从而消除了发生死锁的可能性。
6. 如果在持有锁的情况下调用某个外部方法，那么就需要警惕死锁。
7. 如果在调用某个方法时不需要持有锁，那么这种调用被称为开放调用。依赖于开放调用的类通常能表现出更好的行为。
8. 在程序中尽量使用开放调用。与那些持有锁时调用外部方法的程序相比，更易于对依赖于开放调用的程序进行死锁分析。
9. 重写代码可能导致丢失原子性。（构造一些协议来防止其他线程进入代码的临界区）
10. 正如当多个线程相互持有彼此正在等待的锁而又不释放自己已持有的锁时会发生死锁，当它们在想他的资源合集上等待时，也会发生死锁。
11. 另一种基于资源的死锁形式就是线程饥饿死锁。如果某些任务的结果，那么这些任务往往是产生线程饥饿死锁的主要来源，有界线程池\资源池的相互依赖的任务不能一起使用。
12. 如果必须获取多个锁，那么在设计时必须考虑锁的顺序：尽量减少潜在的加锁交互数量，将获取锁时需要遵循的协议写入正式文档并始终遵循这些协议。
13. 在使用细粒度的程序中，可以通过使用一种两阶段策略来检查代码中的死锁；首先，找出在什么地方获取多个锁（使这个集合尽量小），然后对所有这些实例进行全局分析，从而确保他们在整个程序中获取锁的顺序都保持一致。
14. 支持定时的锁：尽量使用定时的锁了能有效避免死锁问题。
15. 内置锁于获得它们所在的线程栈帧是相关联的，而显示的Lock只与获得它的线程相关联。
16. 当线程由于无法访问它所需要的资源而不能继续执行时，就发生了“饥饿”。引发饥饿的最常见资源就是CPU时钟周期。
17. 在Thread API中定义了十个优先级，JVM根据需要将它们映射到操作系统的调度优先级。这种映射是与特定平台相关的，因此在某个操作系统中两个不同的Java优先级可能被映射到同一个优先级，而在另一个操作系统中则可能被映射到另一个不同不同的优先级。
18. 线程优先级并不是一种直观的机制，而通过修改线程优先级所带来的效果通常也不明显。当提高某个线程的优先级时，可能不会起到任何作用，或者也可能使得某个线程的调度优先级高于其他线程，从而导致饥饿。
19. 活锁：线程不断重复执行想他的操作，而且总会失败。活锁通常发生在处理事务消息的应用程序中：如果不能成功地处理某个消息，那么消息处理机制将回滚整个事务，并将它重新放到队列的开头。
20. 当多个相互协作的线程都对彼此进行响应从而修改各自的状态，并使得任何一个线程都无法继续执行时，就发生了活锁（过度恢复）解决方案：在重试机制中引入随机性，通过等待随机长度的时间和回退可以有效地避免活锁的发生。