## 第十五章 构建自定义的同步工具

1. 在顺序程序中，如果基于状态的前提条件不满足的可以直接失败。但在并发程序中通常更为常见的选择是等待前提条件为真。
2. 依赖状态的操作可以一直阻塞直到可以继续执行，这比使它们先失败再实现起来要更为方便且更不易出错。
3. 构成前提条件的状态变量必须由对象的锁来保护，从而使它们在测试前提条件的同时保持不变，如果前提条件尚未满足，就必须释放锁，以便其他线程可以修改对象的状态，否则，前提条件就永远无法变成真。在再次测试前提交通之前，必须重新获得锁。
4. Thread.yield：这相当于给调度器一个提示：现在需要让出一定的时间使另一个线程运行。
5. 当一个方法由于等待某个条件变成真而阻塞时，需要提供一种取消机制。
6. “条件队列”这个名字来源于：它使得一组线程（称之为等待线程集合）能够通过某种方式来等待特定的条件变成真。传统队列的元素是一个个数据，而与之不同的是，条件队列中的元素是一个个正在等待相关条件的集合。
7. 对象的内置锁与其内部条件队列是相互关联的，要调用对象X中条件队列的任何一个方法，必须持有对象X上的锁。
8. Object.wait会自动释放锁，并请求操作系统挂起当前线程，从而使其他线程能够获得这个锁并修改对象的状态。
9. 条件谓词是使得某个操作称为状态依赖操作的前提条件，是由类中各个状态变量构成的表达式。
10. 在等待中存在一种重要的三元关系，包括加锁、wait方法和一个条件谓词。在条件谓词中包含多个状态变量，而状态变量由一个锁来保护，因此在测试条件谓词之前必须先持有这个锁。锁对象与条件队列对象必须是同一个对象。
11. 当线程从wait方法中被唤醒时，它在重新请求锁时不具有任何特殊优先级，而要与任何其他尝试进入同步代码块的线程一起正常地在锁上进行竞争。
12. 所有各种原因而wait的线程都存在于同一个条件队列（内置）。
13. 每当线程从wait中唤醒时，都必须再次测试条件谓词。
14. 丢失的信号：线程必须等待一个已经成为真的条件，但在开始等待之前没有检查条件谓词。
15. 通知并不像你涂在面包上的果酱，没有“粘附性”。如果线程A通知了一个条件队列，而线程B随后在这个条件队列上等待，那么线程B将不会立即醒来，而是需要另一个通知来唤醒他。
16. 每当在等待一个条件时，一定要确保在条件谓词变为真时通过某这方式发出通知。
17. 只有同时满足两个条件时，才能用单一的notify而不是notifyAll：
    1. 所有等待线程的类型都相同。只有一个条件谓词与条件队列相关，并且每个线程在从wait返回后将执行相同的操作。
    2. 单进单出。在条件变量上的每次通知，最多只能唤醒一个线程来执行。
18. 如果在实施子类化违背了条件通知或者单次通知的某个需求，那么在子类中可以增加合适的通知机制来代表基类。
19. 对于状态依赖的类，要么将其等待通知等协议完全向子类公开，要么完全阻止子类参与到等待通知等过程中。当设计一个可悲继承等状态依赖管理类时，至少需要公开条件队列和锁，并且将条件谓词和同步策略都写入文档。
20. 通常，我们应该把条件队列封装起来，因而除了使用条件队列的类，就不能在其他地方访问它。
21. Wellings通过“入口协议和出口协议”来描述wait和notify的正确使用。入口协议就是该操作的条件谓词，出口协议则包括，检查被该操作修改的所有状态变量，并确认他们是否使某个其他的条件谓词变为真，如果是，则通知相关的条件队列。
22. 内置条件队列存在一些缺陷。每个内置锁都只能有一个相关联的条件队列。
23. 正如Lock比内置加锁提供了更为丰富的功能，Condition同样比内置条件队列提供了更丰富的功能：在每个锁上可存在多个等待、条件等待可以是可中断的或不可中断的、基于时限的等待，以及公平的或非公平的队列操作。
24. 对于每个Lock，可以有任意数量的Condition对象。Condition对象继承了相关的Lock对象的公平性，对于公平的锁，线程会依照FiFO顺序从Condition.await中释放。
25. ReentrantLock要求在调用signal或signalAll时应该持有Lock。
26. AQS是一个用于构建锁和同步器的框架。
27. 不建议扩展AQS，而应该维护一个私有的AQS成员。
28. JUC下的包基本都是基于AQS构建的。
29. ReentrantLock只支持独占方式的获取操作。ReentrantLock将同步状态用于保存锁获取操作的次数，并且还维护一个owner变量来保存当前所有线程的标识符，只有在当前线程刚刚获取到锁，或者正要释放锁的时候，才会修改这个变量。
30. Semaphore将AQS的同步状态用于保存当前可用许可的数量。
31. ReentrantReadWriteLock使用了一个16位的状态来表示写入锁的计数，并且使用了另一个16位的状态来表示读取锁的计数。
32. 在ReentrantReadWriteLock中，当锁可用时，如果位于队列头部的线程执行写入操作，那么线程会得到这个锁，如果位于队列头部的线程执行读取访问，那么队列中在第一个写入线程之前的所有操作都将获得这个锁。