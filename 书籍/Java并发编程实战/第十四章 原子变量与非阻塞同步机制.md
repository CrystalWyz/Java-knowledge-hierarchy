## 第十四章 原子变量与非阻塞同步机制

1. 原子变量提供了与volatile类型变量相同的内存语义，此外还支持原子的更新操作。
2. 当线程在锁上发生竞争时，智能的JVM不一定会挂起线程，而是根据之前获取操作中对锁的持有时间长短来判断是使此线程挂起还是自旋等待。
3. 硬件提供了一些原子操作指令。
4. 在大多数处理器架构中实现原子操作中采用的方法是实现一个比较并交换（CAS）指令。
5. CAS包含了三个操作数——需要读写的内存位置V、进行比较的值A和拟写入的新值B。当且仅当V的值等于A时，CAS才会通过原子方式用新值B来更新V的值，否则不会执行任何操作。无论位置V的值是否等于A，都将返回V原有的值。
6. 使用CAS时，竞争失败的线程不必挂起。
7. CAS适用于竞争程度不高的情况。
8. CAS的主要缺点时，它将使调用者处理竞争问题，而在锁中能自动处理竞争问题。
9. 一个很管用的经验法则是：在大多数处理器上，在无竞争的锁获取和释放的“快速代码路径”上的开销，大约是CAS的两倍。
10. 原子变量比锁的力度更细，量级更轻。
11. 最常用的原子变量就是标量类：AtomicInteger、AtomicLong、AtomicBoolean和AtomicReference。所有这些类都支持CAS，此外，AtomicInteger和AtomicLong还支持蒜素运算。（想要模拟其他基本类型的原子变量，可以将short或byte等类型与int类型进行转换，以及使用floatToIntBits或doubleToLongBits来转换浮点数）
12. 原子数组类（只支持Integer、Long和Reference版本）中的元素可以实现原子更新。原子数组类为数组的元素提供了volatile类型的访问语义，这是普通数组所不具备的特性——volatile类型的数组仅在数组引用上具有volatile语义，而在其他元素上则没有。
13. 几杯类型的包装类是不可修改的，而原子变量类是可修改的（不宜做基于三裂的容器中的键值）。
14. 如果在某种算法中，一个线程的失败或挂起不好导致其他线程也失败或挂起，那么这种算法就被称为非阻塞算法。如果在算法的每个步骤中都存在某个线程能够执行下去，那么这种算法也被称为无锁算法。如果在算法中仅将CAS用于协调线程之间的操作，并且能正确地实现，那么它既是一种无阻塞算法，又是一种无锁算法。
15. 创建非阻塞算法的关键在于，找出如何将原子修改的范围缩小到单个变量上，同时还要维护数据的一致性。
16. 栈是最简单的链式数据结构：每个元素仅向一个元素，并且每个元素也只被一个元素引用。
17. 构建非阻塞算法的技巧在于：将执行原子修改的范围缩小到单个变量上。
18. 在ConcurrentLinkedQueue中没有使用原子引用来表示每个Node，而是使用普通的volitale类型引用，并通过基于反射的AtomicReferenceFieldUpdater。更新器类提供的原子性保证比普通原子类更弱一些，因为无法保证底层的域不被直接修改。
19. 如果在执行原子更新的同时还需要维持现有类的串行化形式，那么原子的域更新器将非常有用。
20. AtomicStampedReference以及AtomicMiakAbleReference支持在两个变量上执行原子的条件更新。