## 第08章 线程池的使用

1. 大多数行为正确的任务都是独立的，如果提交给线程池的任务需要依赖其他的任务，那么就隐含地给执行策略带来了约束。
2. 在标准的Executor实现中，当执行需求较低时将回收空闲线程，而当需求增加时将添加新的线程，并且如果从任务中抛出了一个未检查异常，那么将用一个新的工作者线程来替代抛出异常的线程。在线程池中不应该使用ThreadLocal在任务之间传递值。
3. 只有当任务都是同类型的并且相互独立时，线程池的性能才能达到最佳。
4. 线程饥饿死锁：正在执行任务的线程都由于等待其他任务处于工作队列中的任务而阻塞。
5. 对于计算型密集的任务，在拥有N(CPU)个处理器的系统上，当线程池大小为N+1时，通常能实现最优的利用率。通用公式：N = N(CPU) * U(CPU) * (1 + W/C)（CPU数 * 期望利用率 * (1 + 等待/计算)
6. 线程池：基本大小也就是线程池的目标大小，即在没有任务执行时线程池的大小，并且只有在工作队列满了的情况下才会创建超出这个数量的线程。线程池的最大大小表示可同时活动的线程数量上限。如果某个线程的空闲时间超过了存活时间，那么将被标记为可回首回收的，并且当线程池的当前大小超过了基本大小时，这个线程将被终止。
7. newFixedThreadPool工厂方法将线程池的基本大小和最大大小设置为参数中的指定值，而且创建的线程池不会超时。newCachedThreadPool工厂方法将线程池的最大大小设置为Integer.MAX_VALUE，而将基本大小设置为零，并且将超时时间设置为一分钟，这种方法创建出来的线程池可以无限被扩展，并且当需求降低时会自动收缩。
8. 在创建ThreadPoolExecutor初期，线程并不会立即启动，而是等到有任务提交时才会启动，除非调用prestartAllCoreThreads。
9. ThreadPoolExecutor允许提供一个BlockingQueue来保存等待执行的任务。基本的任务排队方法有3种：无界队列、有界队列和同步移交。
10. newFixedThreadPool和newSingleThreadExecutor在默认情况下将使用一个无界的LinkedBlockingQueue。如果所有工作者线程都处于忙碌状态，那么任务将在队列中等候。如果任务持续快速地到达，并且超过了线程池处理它们的速度，那么任务将在队列中等候。如果任务持续快速地到达，并且超过了线程池处理它们的速度，那么队列将无限制地增加。
11. 可以通过使用SynchronousQueue来避免任务排队，SynchronousQueue不是一个真正的队列，而是一种在线程之间进行移交的机制。如果想要进一步控制任务执行顺序，还可以使用PriorityBlockingQueue，这个队列将根据优先级来安排任务。
12. ThreadPoolExecutor的饱和策略可以通过调用serRejectedExecutionhandler来修改。（如果某个任务的提交一个已被关闭的Executor时，也会用到饱和策略。）JDK提供了几种不同的RejectedExecutionHandler实现：AbortPolicy、CallerRunsPolicy、DiscardPolicy和DiscardOldestPolicy。
13. “中指（Abort）”策略是默认的饱和策略，该策略将抛出未检查的RejectedExceptionException。调用者可以捕获这个异常，然后根据需求编写自己的处理代码。当新提交的任务无法保存到队列中等待执行时，“抛弃（Discard）”策略会悄悄的抛弃该任务。“抛弃最旧的（Discard-Oldest）”策略则会抛弃下一个将被执行的任务，然后尝试重新提交新的任务。（如果工作队列是一个优先队列，那么“抛弃最旧的”策略将导致抛弃优先级最高的任务，因此最好不要将“抛弃最旧的”饱和策略和优先级队列放在一起使用。
14. “调用者运行（Caller-Runs）”实现了一种调节机制，该策略既不会抛弃任务，也不会抛出异常，而是将某些任务回退到调用者，从而降低新任务的流量。
15. 每当线程池需要创建一个线程时，都是通过线程工厂方法来完成的。默认的线程工厂方法将创建一个新的、非守护的线程，并且不包含特殊的配置信息。通过指定一个线程工厂方法，可以定制线程池的配置信息。在ThreadFactory中只定义了一个方法newThread，每当线程池需要创建一个新线程时都会调用这个方法。
16. 在Executors中包含一个unconfigurableExecutorService工厂方法，该方法对一个现有的ExecutorService进行包装，使其只暴露出ExecutorService的方法。
17. ThreadPoolExecutor是可扩展的，它提供了几个可以在子类化中改写的方法：beforeExecute、afterExecute和terminated。
18. 无论任务是从run中正常返回，还是抛出一个异常而返回，afterExecute都会被调用。（如果任务在完成后带有一个Error，那么就不会调用afterExecute）如果beforeExecute抛出一个RuntimeException，那么任务将不被执行，并且afterExecute也不会被调用。
19. 在线程池完成关闭操作时调用terminated，也就是在所有任务都已经完成并且所有工作者线程也已经关闭后。
20. 如果需要提交一个任务集并等待它们完成，那么可以使用ExecutorService.invokeAll，并且在所有任务都执行完成完成后调用CompletionService来获取结果。