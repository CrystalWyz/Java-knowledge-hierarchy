## 第十六章 Java内存模型

1. 在编译器中生成的指令顺序，可以与源代码中的顺序不同。
2. 保存在处理器本地缓存中的值，对于其他处理器是不可见的。
3. Java语言规范要求JVM在线程中维护一种类似于串行的语义：只要程序的最终结果域在严格串行的环境中执行的结果相同，那么上述所有操作都是允许的。
4. 对于并发应用程序中的线程来说，它们在大部分时间里都执行各自的任务，因此在线程之间的协调操作只会降低应用程序的运行速度，而不会带来任何好处。只有当多个线程需要共享数据时，才必须协调他们之间的操作，并且JVM依赖程序通过同步操作来找出这些协调操作将在何时发生。
5. 在共享内存的多处理器体系架构中，每个处理器都拥有自己的缓存，并且定期地与主内存进行协调。在不同的处理器架构中提供了不同级别的缓存一致性，其中一部分只提供最小的保证，即允许不同的处理器在任一时刻从同一个存储位置上看到不同的值。
6. 为了使Java开发人员无需关心不同架构上内存模型之间的差异，Java还提供了自己的内存模型，并且JVM通过在适当的位置上插入内存栅栏来屏蔽在JMM与底层平台内存模型之间的差异。
7. 串行一致性：程序中只存在唯一的操作执行顺序，而不考虑这些操作在何种处理器上执行，并且在每次读取变量时，都能获得在执行队列中（任何处理器）最近一次写入该变量的值。<font color=red>在任何一款现代多处理器架构中都不会提供这种串行一执性。</font>
8. Java程序不需要指定内存栅栏的位置，而只需通过正确使用同步来找出何时将访问共享状态。
9. 个字使操作延迟或者看似乱序执行的不同原因，都可以归结为重排序。
10. 同步将限制编译器、运行时和硬件对内存操作重排序的方式，从而在实施重排序时不会破坏JMM提供的可见性保证。
11. Java内存模型是通过各种操作协议来定义的，包括对变量的读写操作，监视器的加锁和释放操作，以及线程的启动和合并操作。想要保证执行操作B的线程看到操作A的结果（无论A和B是否在同一个线程中执行），那么在A和B之间必须满足Happens-Before关系。如果两操作之间缺乏Happens-Before关系，那么JVM可以对他们任意地重排序。
12. 在类库中提供的其他Happens-Before排序包括：
    1. 将一个元素放入一个线程安全容器的操作将在另一个线程从该容器中获得这个元素的操作之前执行。
    2. 在CountDownLatch上的倒数操作将在线程从闭锁上的await方法中返回之前执行。
    3. 释放Semaphore许可的操作将在从该Semaphore上获得一个许可之前执行。
    4. Future表示的任务的所有操作将在从Future.get中返回之前执行。
    5. 向Executor提交一个Runnable或Callable的操作将在任务开始执行之前执行。
    6. 一个线程到达CyclicBarrier或Exchanger的操作将在其他到达该栅栏或交换点的线程被释放之前执行。如果CyclicBarrier使用一个栅栏操作，那么到达栅栏的操作将在栅栏操作之前执行，而栅栏操作又会在线程从栅栏中释放之前执行。
13. 造成不正确发布的真正原因，就是在“发布一个共享对象”与“另一个线程访问该对象”之间缺少一种Happens-Before排序。
14. 除了不可变对象以外，使用被另一个线程初始化的对象通常都是不安全的，除非对象的发布操作是在使用该对象的线程开始使用之前执行。
15. 同样，通过使用一个由锁保护共享变量或者使用共享的volatile类型变量，也可以确保对该变量的读取操作和写入操作按照Happens-Before关系来排序。
16. 在初始器中采用了特殊的方式来处理静态域。静态初始化器是由JVM在类的初始化阶段执行，即在类被加载后并且被线程使用之前。由于JVM将在初始化期间获得一个锁，并且每个线程都至少获取一次这个锁以确保这个类已经加载，因此在静态初始化期间，内存写入操作将自动对所有线程可见。因此无论是在被构造期间还是被引用时，静态初始化的对象都不需要显示的同步。
17. 初始化安全性将确保，对于被正确构造的对象，所有线程都能看到由构造函数为对象给各个final域设置的正确值，而不管采用何种方式来发布对象。而且，对于可以通过被正确构造对象中某个final域到达的任意变量（例如某个final数组中的元素，或者由一个final域引用的HashMap的内容）将同样对于其他线程是可见的。
18. 对于含有final域的对象，初始化安全性可以防止对对象的初始引用被重排序到构造过程之前。当构造函数完成时，构造函数对final域的所有写入操作，以及通过这些域可以到达的任何变量的写入操作，都将被“冻结”，并且任何获得该对象引用的线程都至少能确保看到被冻结的值。对于通过final域可到达的初始变量的写入操作，将不会与构造过程后的操作一起被重排序。
19. 初始化安全性只能保证通过final域可达的值从构造过程完成时开始的可见性。