## 对象的组合

1. 状态封装能获得线程安全性。
2. 在设计线程安全类的过程中，需要包含以下三个要素：
   1. 找出构成对象的所有变量。
   2. 找出约束状态变量的不变性条件。
   3. 建立对象状态的并发访问管理策略。
3. 如果对象中所有的域都是基本类型的变量，那么这些域将构成对象的全部状态。
4. 对于含有n个基本类型域的对象，其状态就是这些域构成的n元组。
5. 如果在对象的域中引用了其他对象，那么该对象的状态将包含被引用对象的域。
6. 同步策略定义了如何在不违背对象不变性条件或后验条件的情况下对其状态的访问操作进行协同。同步策略规定了如何将不可变性、线程封闭与加锁机制等结合起来以维护线程的安全性，并且还规定了哪些变量由哪些锁来保护。
7. 要确保类等线程安全性，就需要确保它的不变性条件不会再并发访问的情况下被破坏（一个安全状态 -> 另一个安全状态），这就需要对其状态进行推断。对象的变量都有一个状态空间，即所有可能的取值。状态空间越小，就越容易判断线程的状态。final类型的域使用得越多，就越能简化对象可能状态的分析过程。（在极端情况下，不可变对象只有唯一的状态。）
8. 后验条件：当下一个状态需要依赖当前状态时，这个操作就必须是一个复合操作。并非所有的操作都会在状态转换上施加限制。
9. 由于不变性条件以及后验条件在状态及状态转换上施加了各种约束，因此就需要额外的同步与封装。如果某些状态时无效的，那么必须对底层的状态变量进行封装，否则客户代码可能会使对象处于无效状态。如果在某个操作中存在无效的状态转换，那么该操作必须是原子的。另外，如果在类中没有施加这种约束，那么就可以放宽封装性或序列化等需求，以便获得更高的灵活性或性能。
10. 在类中也可以包含同时约束多个状态变量的不变性条件。类似于这种包含多个变量的不变性条件将带泪原子性需求：这些相关的变量必须在单个原子操作中进行读取或更新。不能首先更新一个变量，然后释放锁并再次获得锁，然后再更新其他变量。因为释放锁后，可能会使对象处于无效状态。如果在一个不变性条件中包含多个变量，那么在执行任何访问相关变量的操作时，都必须持有保护这些变量的锁。
11. 如果在某个操作中包含有基于状态的先验条件，那么这个操作就称为依赖状态的操作。
12. 如果以某个对象为根节点构造一张对象图，那么该对象的状态将是对象图中所有对象包含的域的一个子集。
13. 如果发布了某个可变对象的引用，那么就不再拥有独占的控制权，最多时“共享控制权”。对于从构造函数或者从方法中传递进来的对象，类通车并不拥有这些对象。
14. 容器类通常表现出一种“所有权分离”的形式，其中容器类拥有其自身的状态，而客户代码则拥有容器中各个对象的状态。
15. 当一个对象被封装到另一个对象中时，能否访问被封装对象的所有代码路径都是已知的。
16. 将数据封装在对象内部，可以将数据的访问限制在对象的方法上，从而更容易确保线程在访问数据时总能持有正确的锁。
17. 实例封闭时构建线程安全类的一个最简单方式，它还使得在锁策略的旋转式拥有了更多的灵活性。
18. Java监视器模式，即内置锁。
19. 线程安全性委托：一个类由其他类组合而成的，那么这个类的线程安全性可以委托给组件类，由组建类共同决定。
20. 如果一个类是由多个独立且线程安全的状态变量构成，并且在所有的操作中都不包含无效的状态转换，那么可以将线程安全性委托给底层的状态变量。
21. 仅当一个变量参与到包含其他状态变量的不变性条件时，才可以声明为volatile类型。
22. 如果一个状态变量是线程安全的，并且没有任何不变性条件来约束它的值，在变量的操作上也不存在任何不允许的状态转换，那么就可以安全地发布这个变量。
23. “扩展”方法比直接将代码添加到类中更脆弱，因为现在的同步策略实现被分不到多个单独维护的源代码中。如果底层的类改变了同步策略并选择了不同的锁来保护它的状态变量，那么子类会被破坏，因为在同步策略改变后它无法再使用正确的锁来控制对基类状态的并发访问。（使用扩展类时需要注意锁对象问题）