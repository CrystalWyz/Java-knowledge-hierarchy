## 第05章 构建基础模块

1. 同步容器类都是线程安全的，但在某些情况下可能需要额外的客户端加锁来保护复合操作。

2. 为同步容器添加新的原子方法时，注意锁对象相同。

3. 在设计同步容器类的<font color="red">迭代</font>时没有考虑到并发修改的问题，当它们发现容器在迭代过程中被修改时，就会抛出ConcurrentModificationException异常。它们采用的实现方式是，将计数器的变化与容器关联起来：如果在迭代期间计数器被修改，那么hasNext或next将抛出ConcurrentModificationException。

4. 如果不希望在迭代期间对容器加锁，那么一种替代方案就是“克隆”容器，并在副本上进行迭代。

5. 编译器将字符串的连接操作（+）转换为调用StringBuilder.append(Object)，而这个方法又会调用容器的toString方法，标准容器的toString方法将迭代容器，并在每个元素上调用toString来生成容器内容的格式化表示。（<font color="red">StringBuilder类的toString方法会隐式迭代！！</font>，容器的hashCode和equals等方法也会间接地执行迭代操作）

6. 同步容器将所有对容器状态的访问都穿行话，以实现它们的线程安全性。这种方法的代价是严重降低并发性，当多个线程竞争容器的锁时，吞吐量将严重降低。（通过并发容器来代替同步容器，可以极大地提高伸缩性并降低风险）

7. 在Java5.0中增加了ConcurrentHashMap，用来替代同步且基于散列的Map，以及CopyOnWriteArraylist，用于在便利操作为主要操作的情况下替代同步的List。

8. Java5.0增加了两种新的容器类型：Queue和BlockingQueue。Queue用来临时保存一组等待处理的元素。它提供了几种实现，包括：ConcurrentLinkedQueue，这是一个传统的并发的先进先出队列，以及PriorityQueue，这是一个非并发的优先队列。Queue上的操作不会阻塞，如果队列为空，那么获取元素的操作将返回空值。（底层通过LinkedList来实现Queue）

9. BlockingQueue扩展了Queue，增加了可阻塞的插入和获取等操作。如果队列为空，那么获取元素的操作将一直阻塞，直到队列中出现一个可用的元素。如果队列已满（对于有界队列来说），那么插入元素的操作将一直阻塞，直到队列中出现可用的空间。

10. Java 6 也引入了ConcurrentSkipListMap和ConcurrentSkipListSet，分别作为同步的SortedMap和SortedSet的并发替代品。

11. 同步容器类在执行每个操作期间都持有一个锁。

12. ConcurrentHashMao并不是将每个方法都在同一个锁上同步并使得每次只有一个线程访问容器，而是使用一种粒度更细的锁机制来实现更大程度的共享，这种机制称为分段锁。在这种机制中，任意数量的读线程可用并发地访问Map，执行读操作的线程和执行写操作的线程可用并发地访问Map，并且一定数量的写入线程可用并发地修改Map。

13. ConcurrentHashMap与其他并发容器一起增强了同步容器类：它们提供的迭代器不会抛出ConcurrentModificationException，因此不需要在迭代过程中对容器加锁。ConcurrentHashMap返回的迭代器具有弱一致性，而并非“及时失败”。弱一致性的迭代器可用容忍并发的修改，当创建迭代器时会便利已有的元素，并可以（但是不保证）在迭代器被构造后将修改操作反映给容器。

14. 对于一些需要在整个Map上进行计算的方法，例如size和isEmpty，这些方法的语义被略微减弱了以反映容器的并发特性。由于size返回的结果在计算时可能已经过期了，它实际上是一个估计值，因此允许size返回一个近似值而不是一个精确值。

15. 在ConcurrentHashMap中没有实现对Map加锁以提供独占的访问。

16. CopyOnWriteArrayList用于替代同步List，在某些情况下它提供了更好的并发性能，并且在迭代期间不需要对容器进行加锁或复制。

    核心：写入时复制。线程安全性在于：只要正确地发布一个事实不可变对象，那么在访问该对象时就不需要再进一步的同步（弱一致性），在每次修改时，都会创建并重新发布一个新的容器副本，从而实现可变性。

17. “写入时复制”容器返回的迭代器不会抛出ConcurrentModificationException，并且返回的元素与迭代器创建时的元素完全相同（迭代器副本？），而不比考虑之后修改操作所带来的影响。

18. 每当修改容器时都会复制底层数组，仅当迭代操作远远多于修改操作时，才应该使用“写入时复制”容器。

19. 阻塞队列提供了可阻塞的put和take方法，以及支持定时的offer和poll方法。如果队列已经满了，那么put方法将阻塞直到有空间可用；如果队列为空，那么take方法将阻塞直到有元素可用。队列可以是有界的也可以是无界的，无界队列永远都不会充满，因此无界队列上的put方法也永远不会阻塞。（生产者——消费者模式）

20. 生产者——消费者模式：将“找出需要完成的工作”与“执行工作”分离，并把工作项放入一个“待完成”列表中以便在随后处理，而不是找出后立即处理。消除了生产者类和消费者类之间的代码依赖性（消息中间件？）

21. PriorityBlockingQueue是一个按优先级队列排序的队列，可以根据元素的自然顺序来比较元素（如果它们实现了Comparable方法），也可以使用Comparator来比较。

22. SynchronousQueue不会为队列中元素维护存储空间，它维护一组线程，这些线程在等待着把元素加入或移出队列。（维护一组消费者）

23. 线程封闭对象只能由单个线程拥有，但可以通过安全地发布该对象来“转移”所有权。在转移所有权后，也只有另一个线程能获取这个对象的访问权，并且发布对象的线程不会再访问它。

24. Deque时一个双端队列，实现了再队列头和队列尾的高效插入和移除。具体实现包括ArrayDeque和LinkedBlockingDeque。

25. 双端队列同样适用工作密取。在生产者-消费者设计中，所有消费者有一个共享的工作队列，而在工作密取的设计中，每个消费者都有各自的双端队列。如果一个消费者完成了自己双端队列中的全部工作，那么它可以从其他消费者双端爹列末尾秘密地获取工作。

26. 密取工作模式比传统的生产者-消费者模式具有更高的可伸缩性，这是因为工作者线程不会再单个共享的任务队列上发生竞争。在大多数时候，它们都只是访问自己的双端队列，从而极大地减少了竞争。当工作者线程需要访问另一个队列时，它会从队列的尾部而不是头部获取工作，因此进一步降低了队列上的竞争程度。

27. 工作密取非常适用于既是消费者也是生产者问题。当一个工作线程找到新的任务单元时，它会将其放到自己队列的末尾（或者在工作共享设计模式中，放入其他工作者线程队列中）。当双端队列为空时，它会在另一个线程的队列队尾查找新的任务，从而确保每个线程都保存忙碌状态。（ForkJoinPool）

28. 阻塞操作与执行时间很长的普通操作区别在于，被阻塞的线程必须等待某个不受它控制的事件发生后才能继续执行。

29. 当某个方法抛出InterruptedException时，表示该方法是一个阻塞方法，如果这个方法被中断，那么它将努力提前结束阻塞状态。

30. Thread提供了interrupt方法，用于中断线程或者查询线程是否已经被中断。每个线程都有一个布尔类型的属性，表示线程的中断状态，当中断线程时将设置这个状态。

31. 中断是一种协作机制。一个线程不能强制其他线程停止正在执行的操作而去执行其他操作。当线程A中断B时，A仅仅要求B在执行到某个可以暂停的地方停在正在执行的操作——前提是如果线程B愿意停止下来。（最常用使用中断的情况就是取消某个操作）

32. 当在代码中调用了一个将抛出InterruptedException异常的方法时，你自己的方法也就变成了一个阻塞方法，并且必须要处理对中断的响应。

33. 同步工具类可以是任何一个对象，只要它根据其自身状态来协调线程的控制流。所有的同步工具类都包含一些特定的结构化属性：它们封装了一些状态，这些状态将决定执行同步工具类的线程时继续执行还是等待，此外还提供了一些方法对状态进行操作，以及一些方法用于高效地等待同步工具类进入到预期状态。

34. 闭锁可以延迟进程的进度直到其到达终止状态。闭锁的作用相当于一扇门：在闭锁到达结束状态之前，这扇门一直是关闭的，并且没有任何线程能通过，当到达结束状态时，这扇门会打开并允许所有的线程通过。当闭锁到达结束状态后，将不会再改变状态，因此这扇门永远保持打开状态。（可以用来确保某些活动直到其他活动都完成后才继续执行）

35. CountDownLatch是一种灵活的闭锁实现。闭锁的状态包括一个计数器，该计数器被初始化为一个正数，表示需要等待的事件数量。countDown方法递减计数器，表示有一个事件已经发生，而await方法等待计数器到达零，这表示所有需要等待的事件都已经发生。如果计数器的值非零，那么await会一直阻塞直到计数器为零，或者等待中的线程中断，或者等待超时。

36. FutureTask也可以用作闭锁。FutureTask表示的计算是通过Calable来实现的，相当于一种可生成结果的Runnable，并且可以处于以下三种状态：等待运行，正在运行和运行完成。“执行完成”表示计算的所有可能结束方式，包括正常结束、由于取消而结束和由于异常而结束等。

37. Future.get到行为取决于任务的状态。如果任务已经完成，那么get会立即返回结果，否则get将阻塞直到任务进入完成状态，然后返回结果或者抛出异常。

38. FutureTask在Executor框架中表示异步任务，通过提前启动计算，可以减少在等待结果时需要的时间。

39. Callable表示的任务可以抛出受检查的异常，并且任何代码都可能抛出一个Error。无论任务代码抛出什么异常，都会被封装到一个ExecutionException中，并在Future.get中被重新抛出。这将使调用get的代码变得更复杂，因为它不仅需要处理可能出现的ExecutionException（以及未检查的CancellationException），而去还由于ExecutionException是作为一个Throwable类返回的，因此处理起来并不容易。

40. 技术信号量用来控制同时访问某个特定资源的操作数量，或者同时执行某个指定操作的数量。技术信号量还可以用来实现某种资源池,或者对容器施加边界。

41. Semaphore中管理者一组虚拟的许可，如果没有许可，那么acquire将阻塞直到有许可（或者指导被中断或者操作超时）。release方法将返回一个许可给信号量。Semaphore也不会将许可与线程关联起来，可以将acquire操作视为是消费一个许可，而release操作是创建一个许可，Semaphore并不受限于它在创建时的许可数量。

42. 栅栏类似于闭锁，他能阻塞一组线程直到某个事件发生。栅栏与闭锁的关键区别在于，所有线程必须同时到达栅栏位置，才能继续执行。闭锁用于等待事件，而栅栏用于等待其他线程。

43. CyclicBarrier可以使一定数量的参与方反复地在栅栏位置汇集，它在并行迭代算法中非常有用：这种算法通常将一个问题拆分成一系列相互独立的子问题。当线程到达栅栏位置时将调用await方法，这个方法将阻塞直到所有线程都到达栅栏位置。如果所有线程都到达零栅栏位置，那么栅栏将打开，此时所有线程都被释放，而栅栏将被重置以便下次使用。如果对await的调用超市，或者await阻塞的线程被中断，那么栅栏就被认为是打破了，所有阻塞的await调用都将终止并抛出BrokenBarrierException。如果成功地通过栅栏，那么await将为每个线程返回一个唯一的到达索引号，我们可以利用这些索引来“选举”产生一个领导线程，并在下一次迭代中由该领导线程执行一些特殊的工作。

44. Exchanger，是一种两方栅栏，各方在栅栏位置上交换数据。