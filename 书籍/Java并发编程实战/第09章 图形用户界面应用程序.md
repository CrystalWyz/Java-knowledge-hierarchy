## 第09章 图形用户界面应用程序

1. 早起的GUI应用程序都是单线程的，并且GUI事件在“主事件循环”进行处理。当前的GUI框架则使用了一种略有不同的模型：在该模型中创建一个专门事件分发线程来处理GUI事件。

2. 但线程的GUI框架通过线程封闭机制来实现线程安全性。

3. 在事件线程中执行的任务必须尽快地把控制权交还给事件线程。要启动一些执行时间较长的任务，必须在另一个线程中执行这些任务。

4. 在GUI应用程序中，事件在事件线程中产生，并通过“气泡上升”的方式传递会给应用程序提供的监听器，而监听器则根据收到的时间执行一些计算来修改表现的对象。

5. 长时间的GUI任务：

   ​															完成后提交新的事件到主事件循环

   修改GUI状态 -> 开线程执行 -————————————————-————>修改GUI状态     （线程接力）

6. 只有GUI应用程序很少会发起大量的长时间任务，因此即使线程池可以无限制地增长也不会有太大的风险。

7. 如果调用Future的cancel方法，并将参数myInterruptIfRunning设置为true，那么这个Future可以中断正在执行任务的线程。

8. 在FutureTask中也有一个done方法同样有助于实现完成通知。

9. 当获取一个“写时拷贝”容器的迭代器时，这个迭代器将遍历整个容器。然而，只有在便利操作远远多于修改操作时，“写时拷贝”容器才能提供更好的性能。

10. 如果在程序中既包含用于表示的数据模型，又包含应用程序特定的数据模型，那么这种应用程序就被称为拥有一种分解模型设计。

11. 在分解模型设计中，表现模型被封闭在事件线程中，而其他模型，即共享模型，是线程安全的，因此既可以由事件线程方法，也可以由应用程序线程访问。表现模型会注册共享模型的监听器，从而在更新时得到通知。然后，表示模型可以在共享模型中得到更新：通过将相关数据的快照嵌入到更新消息中，或者由表现模型在收到更新事件时直接从共享模型中获取数据。

12. 如果一个数据模型必须背多个线程共享，而且由于阻塞、一致性或复杂度等原因而无法实现一个线程安全的模型时，可以考虑使用分解模型设计。（使用快照时优先考虑传递增量数据）

13. 使用一个专门的线程维持线程封闭对象，其他线程需要访问时提交一个任务给此线程。