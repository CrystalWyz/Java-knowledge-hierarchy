## 第06章 任务执行

1. 大多数并发应用程序都是围绕“任务执行”来构造的：任务通常是一些抽象的且离散的工作单元。
2. 找出清晰的任务边界：在理想情况下，各个任务之间是相互独立的：任务并不依赖其他任务的状态、结果或边界效应。独立性有助于实现并发，因为如果存在足够多的处理资源，那么这些独立的任务都可以并行执行。
3. 在单线程的服务器中，阻塞不仅会推迟当前请求的完成时间，而且将彻底阻止等待中的请求被处理。如果请求阻塞的时间过长，用户将认为服务器是不可用的，因为服务器看似失去了响应。同时，服务器的资源利用率非常低，因为当单线程在等待I/O操作完成时，CPU将处于空闲状态。
4. 无限制创建线程的不足：
   1. 线程生命周期的开销非常高：线程的创建与销毁并不是没有代价的。根据平台的不同，实际的开销也有所不同，但线程的创建过程都会需要时间，延迟处理的请求，并且需要JVM和操作系统提供一些辅助操作。如果请求的到达率非常高且请求的处理过程是轻量级的，例如大多数服务器应用程序就是这种情况，那么为每个请求创建一个新线程将消耗大量的计算资源。
   2. 资源消耗：活跃的线程会消耗系统资源，尤其是内存。
   3. 稳定性：在可创建线程的数量上存在一定的限制。这个限制值将随着平台的不同而不同，并且受多个因素的制约，包括JVM的启动参数、Thread构造函数中请求的栈大小，以及底层操作系统对线程的限制等。
5. 在一定的范围内，增加线程可以提高系统的吞吐率，但如果超出了这个范围，再创建更多的线程只会降低程序的执行速度，并且如果过多地创建一个线程，那么整个应用程序将崩溃。
6. 任务是一组逻辑工作单元，而线程则是使任务异步执行的机制。
7. 每个线程都维护两个执行栈，一个用于Java代码，另一个用于原生代码。通常，JVM在默认情况下会生成一个复合栈，大小约为0.5MB。
8. 线程池，从字面含义来看，是指一组同构工作线程的资源池。线程池是与工作队列密切相关的，其中在工作队列中保存了所有等待执行的任务。工作者线程的任务很简单：从工作队列中获取一个任务，执行任务，然后返回线程池并等待下一个任务。
9. 通过重用现有的线程而不是创建新线程，可以在处理多个请求时分摊在线程创建和销毁过程中产生的巨大开销。不会由于等待创建线程而延迟任务的执行，从而提高了响应性。
10. 多种线程池：
    1. FixedThreadPool：通过newFixedThreadPool将创建一个固定长度的线程池，每当提交一个任务时就创建一个线程，直到达到线程池的最大数量，这时线程池的规模将不再变化。（最大固定的线程数量）
    2. CachedThreadPool：通过newCachedThreadPool将创建一个可缓存的线程池，如果线程池的当前规模超过了处理请求时，那么将会瘦空闲的线程，而当需求增加时，则可以添加新的线程，线程池的规模不存在任何限制。
    3. SingleThreadExecutor：通过newSingleThreadExecutor创建一个但线程的Executor，它创建单个工作者线程来执行任务，如果这个线程异常结束，会创建另一个线程来替代。newSingleThreadExecutor能确保依照任务在队列中的顺序来串行执行。（单线程的Executor还提供了大量的内部同步机制，从而确保了任务执行的任何内存写入操作对后续任务的来说可说都是可见的）
    4. ScheduledThreadPool：通过newScheduledThreadPool创建一个固定长度的线程池，而且以延迟或定时的方式来执行任务。
11. Executor的实现通常会创建线程来执行任务。但JVM只幼崽所有（非守护）线程全部终止后才会退出。因此，如果无法正确的关闭Executor，那么JVM将无法结束。
12. 由于Executor以异步的方式来执行任务，因此在任何时刻，之前提交任务的状态不是立即可见的。
13. 为了解决执行服务的生命周期问题，Executor扩展了ExecutorService接口，添加了一些用于生命周期管理的方法。
14. ExecutorService的生命周期有三种状态：运行、关闭和已终止。ExecutorService在初始创建时处于运行状态。shutdown方法将执行平缓的关闭过程：不再接收新的任务，同时等待已经提交的任务执行完成——包括哪些还未开始执行的任务。shutdownNow方法将执行粗暴的关闭过程：他将尝试取消所有运行中的任务，并且不再启动队列中尚未开始执行的任务。
15. 在ExecutorService关闭后提交的任务由“拒绝执行处理器”来处理，它会抛弃任务，或者使得execute方法抛出一个为检查的RejectedExecutionException。等所有任务都完成后，ExecutorService将转入终止状态。可以调用awaitTermination来等待ExecutorService到达终止状态，或者通过调用isTerminated来轮询ExecutorService是否已经终止。通常在调用awaitTermination之后会立即调用shutdown，从而产生同步地关闭ExecutorService的效果。
16. Timer类负责管理延迟任务以及周期任务。然而，Timer存在一些缺陷，因此应该考虑使用ScheduledThreadPool来代替它：
    1. Timer在执行所有定时任务时只会创建一个线程。如果某个任务的执行时间过长，那么将破坏其他TimerTask的定时精确性。
    2. Timer的另一个问题是，如果TimerTask抛出了一个未受检查的异常，那么Timer将表现出糟糕的行为。Timer线程并不捕获异常，因此当TimerTask抛出未受检查的异常时将终止定时线程。
17. 如果要构建自己的调度任务，那么可以使用DelayQueue，它实现了BlockingQueue，并为ScheduledTThreadPoolExecutor提供调度功能。DelayQueue管理着一组Delayed对象。每个Delayed对象都有一个相应的延迟时间：在DelayQueue中，只有某个元素逾期后，才能从DelayQueue中执行take操作。从DelayQueue中返回的对象将根据他们的延迟时间进行排序。
18. Runnable局限：不能返回一个值或者抛出一个受检查的异常。解决方案：Callable。
19. Runnable和Callable描述的都是抽象的计算任务。这些任务通常都是有范围的，即有一个明确的起始点，并且最终都会结束。Executor执行的任务由四个生命周期阶段：创建、提交、开始和完成。由于有些任务可能要执行很长时间，因此通常希望能取消这些任务。在Executor框架中，已提交但尚未开始的任务可以取消，但对于那些已经开始执行的任务，只有当它们能响应中断时，才能取消。取消一个已经完成的任务不会有任何影响。
20. Future表示一个任务的生命周期，并提供了相应的方法来判断是非已经完成或取消，以及获取任务的结果和取消任务等。
21. get方法的行为取决于任务的状态（尚未开始、正在运行、已完成）。如果任务已经完成，那么get会立即返回或者抛出一个Exception。如果任务没有完成，那么get将阻塞并指导任务完成。如果任务抛出了异常，那么get将该异常封装为ExecutionException并重新抛出。如果任务被取消，那么get将抛出CancellationException。如果get抛出了ExecutionException，那么可以通过getCause来获得被封装的初始异常。
22. 可以通过许多方法创建一个Future来描述任务。ExecutorService中的所有submit方法都将返回一个Future，从而将一个Runnable或Callable提交给Executor，并得到一个Future用来获得任务的执行结果或取消任务。还可以显式地为某个指定的Runnable或Callable实例化一个FutureTask。（由于FutureTask实现了Runnable，因此可以将它提交给Executor来执行或者直接调用它的run方法）
23. 只有当大量独立且同构的任务可以并发进行处理时，才能体现出将程序的工作负载分配到多个任务重带来的真正的性能提升。
24. CompletionService将Executor和BlockingQueue的功能融合在一起。你可以将Callable任务提交给它来执行，然和使用类似于队列操作的take和poll等方法来获得已完成的结果，而这些结果会在完成时将被封装为Future。ExecutorCompletionService实现了CompletionService，并将计算结果部分委托给一个Executor。
25. ExecutorCompletionService实现非常简单。在构造函数中创建一个BlockingQueue来保存结算结果。当计算完成时，调用FutureTask中的done方法。当提交某个任务时，该任务将首先包装为一个QueueingFuture，这是FutureTask的一个字累，然后再改写子类的done方法，并将结果放入BlockingQueue中。take和poll方法委托给BlockingQueue，这些方法会在得出结果之前阻塞。
26. 多个ExecutorCompletionService可以共享一个Executor，因此可以创建一个对于特定计算私有，又能共享一个公共Executor的ExecutorCompletionService。
27. invokeAll方法的参数为一组任务，并返回一组Future，这两个集合有着相同的结构。invokeAll按照任务集合中的迭代器的顺序将所有的Future添加到返回的集合中，从而使调用者能将各个Future与其表示的Callable关联起来。