## 第05章 Pod

1.  资源隔离是容器的主要职责。
2. Kubernetes将多个容器分组放入一个名为Pod的原子弹有中。
3. Pod代表了在同一个执行环境中运行的应用程序容器和卷的集合。Kubernetes集群中的最小可部署单元。
4. Pod中的每个容器都在自己的cgroup中运行，但是他们共享许多Linux命名空间。
5. 在同一个Pod中运行的应用程序共享同一个IP地址和端口空间，拥有相同的主机名（UTS命名空间），而且还可以使用System V IPC或POSIX消息队列（IPC命名空间）上本地进程间的通信通道进行通信。
6. Kubernetes API服务器在接收到Pod清单后，会对其进行处理，然后在保存到持久存储中。Kubernetes调度器会设法将同一个应用程序分散到多台机器上。
7. 最简单的创建Pod方法就是直接运行kubectl run命令。
8. 通常采用YAML或JSON格式编写Pod清单。
9. 默认情况下，kubectl命令行工具会尽量简化报告的信息。
10. 删除Pod时 ，Pod不会立即被干掉。所有Pod都有终止宽限期，默认为30秒。删除Pod的时候，存储在相关容器中的所有数据也会被删除。
11. 端口转发：kubectl port-forward 从本地计算机开始，经由Kubernetes的主节点，连接到在其中一个工作节点上运行的Pod实例。
12. kubectl logs添加--previous标志之后，就可以获取容器前一个实例的日志。
13. 在容器的上下文中执行命令：kubectl exec。 通过-it标志来建立交互式会话。
14. 将应用程序作为容器在Kubernetes中运行时，Kubernetes会自动执行进程健康检查，以确保应用程序处于活动状态。这种健康检查只能确保应用程序的主进程始终处于运行状态。如果主进程没有运行，Kubernetes就会重启应用程序。
15. 存活健康检查时哥哥应用程序专用的，因此你必须在Pod清单中定义它们。
16. 存活探针时针对每个容器定义的，这意味着Pod内的每个容器都需要分别进行健康检查。
17. 尽管存活探针失败后的默认响应是重启Pod，但实际的行为由Pod的restartPolicy控制，由三个选项：Always，OnFailure(仅在存活探针失败或进程的退出码为非零时重启)或Never
18. Kubernetes的健康检查分为存活探针和就绪探针。存活探针决定应用程序是否正常运行。凡是未通过存活探针的容器都会被重启。而就绪探针则表明容器何时准备好服务用户请求。凡是未通过就绪探针的容器都会从服务负载均衡器中移除。
19. 除了HTTP检查之外，Kubernetes还支持tcpSocket健康检查，这种健康检查能够打开TCP套接字。如果连接成功，则探针成功。
20. Kubernetes还支持exec探针。这些探针可以在容器的上下文中执行脚本或程序。按照通常的约定，如果脚本返回的退出码为0，则代表探测成功。
21. Kubernetes允许用户指定两个不同的资源指标。资源请求指定运行应用程序所需的最小资源量。资源约束指定应用程序可以使用的最大资源量。
22. Pod可以请求运行其容器所需的资源。Kubernetes可以保证Pod能拿到这些资源。
23. 资源请求是以容器为单位进行的，而不是以Pod为单位。Pod请求的资源综合是Pod中所有容器请求的所有资源之和。
24. Kubernetes调度器会确保节点上所有Pod请求的资源总和不会超过该节点的容量。Pod在节点上运行时，至少能获得请求的资源量。
25. CPU请求是通过Linux内核中的cpu-shares功能实现的。
26. 如果容器使用的内存量超出请求，则操作系统无法简单的从进程中删除内存，因为内存已经被分配出去了。因此，当系统内存不足时，kubelet会终止内存使用量大于请求值的容器。这些容器会自动重启，但该容器能使用的内存量会减少。
27. 如果想将卷加到Pod清单，我们需要在配置中添加两个新的小节。第一个小节是spec.volumes，这个数组定义了Pod清单中的容器可以访问的所有卷。第二个小节是容器定义中的volumeMounts数组。该数组定义了挂载到特定容器的卷，以及加载每个卷的路径。请注意，Pod中两个不同的容器可以通过不同的加载路径加载同一个卷。
28. emptyDir卷寿命与Pod一致，但是可以在两个容器之间共享。hostPath卷可以将工作节点上的任意位置挂载到容器中。