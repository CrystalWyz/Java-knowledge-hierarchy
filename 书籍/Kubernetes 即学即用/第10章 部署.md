## 第10章 部署

1. Pod和副本集都应该用于某个不会发生变化的容器镜像上。
2. 使用Deployment对象管理新版本的发布。Deployment表示已部署的应用程序，但不限于任何特定的版本。此外，Deployment可以帮助你将代码从一个版本转移到下一个版本。这个“推出”过程是可以指定的，而且非常谨慎。部署会再升级各个Pod之间等待一段时间（间隔可由用户配置）。而且Deployment还会通过健康检查来确保新版本的应用程序正常运行，如果发生太多故障，则部署会停止。
3. Pod由副本集负责管理，而副本集由Deployment负责管理。副本集与Deployment之间的关系也是哦通过标签和标签选择器定义的。随着Deployment的伸缩，它所控制的副本集也会伸缩。
4. 如果想直接管理副本集，则需要删除部署（请不要忘记将--cascade设置为false，否则会连副本集和Pod一起删除）
5. 执行kubectl replace --save-config，这个命令会添加一个注释，以便将来应用更改时，kubectl知道上一次应用的配置是什么，才能对多个配置进行智能合并。
6. strategy对象规定了推出新软件的方式，支持两种策略：Recreate和Rollingupdate。
7. 可以使用kubectl rollout history来获取与特定部署相关的推出历史记录。如果部署正在进行中，则可以使用kubectl rollout status获取推出的当前状态。
8. 如果推出正在进行，出于某种原因想暂停，则可以使用：kubectl rollout pause。如果经过检查，认为可以继续，可以使用：kubectl rollout resume
9. 记录是按照从就到新的顺序显示的。每次推出新版本时，修订号都会加1以保证唯一性。如果你对某个特定的修订感兴趣，则可以加上--revision标志，查看有关该修订的详细信息。
10. 执行回滚：kubectl rollout undo 执行与部署阶段无关。可以撤销部分完成的部署，也可以撤销全部完成的部署。推出的撤销行为实际上只是一次反向推出。所做的状态修改并不会反映再源代码控制中。
11. 当你回滚到前一个修订版时，Deployment只是简单地重用前一个版本的模板并重新编号，前一个版本就摇身变成了最新的修订版。 可以使用--to-revision标志回滚到历史记录中的某个特定版本 指定为0相当于指定前一个修订版。
12. 默认情况下，完整的部署修订历史会附加到部署对象本身。使用revisionHistoryOimit模板参数为部署的修订历史记录设置一个最大值，以限制部署对象的总大小。
13. Kubernetes支持两种部署策略
    1. Recreated：重建，更新自己管理的副本集，让他们使用新镜像，并终止所有与部署相关联的Pod。副本集会注意到自己没有任何副本时，就会使用镜像重新创建所有的Pod。重新创建的Pod会运行新版本，但会导致网站停机一段时间。
    2. RollingUpdate：可以在服务接收用户流量的同时推出新版本的服务，而且不会造成停机。一次只更新几个Pod，直到所有的Pod都运行新版本的软件（注意版本兼容）
14. 可以通过两个参数来调整滚动更新行为：
    1. maxUnavailable：负责设置滚动更新过程中不可用Pod的最大数值。可以将其设置为绝对数值，也可以为百分数值。核心思想是调整滚动更新的进行速度。
    2. maxSurge参数控制可以创建多少资源来确保成功地实施推出。
15. 部署控制器会等待Pod报告已准备就绪（就绪探针），等待时间由参数minReadySeconds定义。
16. 等待超时使用progressDeadlineSeconds，推出过程中的任何特定阶段未能在指定时间内有任何进展，则此次部署会被标记为失败，而且所有继续推进部署的尝试都会被暂停。
17. 删除部署默认会删除整个服务。不仅会删除部署，而且还会删除该部署管理的所有副本集，以及该副本集管理的所有Pod。如果不想删除部署之外的东西，则可以使用--cascade=false标志指明只删除部署对象。