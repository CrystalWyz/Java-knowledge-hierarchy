## 第14章 基于角色的访问控制

1. 基于角色的访问控制提供了一种机制，可以限制对Kubernetes API的访问和动作，确保只有适当的用户才能访问集群中的API。
2. Kubernetes的每个请求首先都必须经过身份认证。身份认证为请求的发送者提供了身份。身份验证可以简单地只判断请求是否通过认证，也可以与插件式的身份验证提供程序深度集成，在第三方系统中建立身份。有趣的是，Kubernetes并没有提供内置的身份存储，而是专注于与其他身份认证源的集成。
3. 在用户被正确识别后，接下来的授权阶段将确定他们是否有权执行请求。授权是用户身份、资源以及用户石头执行的动作的组合。如果特定用户得到了授权，可以在该资源上执行该操作，则请求可以继续。
4. Kubernetes收到的每个请求都与某个身份关联。甚至没有身份的请求也会与system:unauthenticated组关联。Kubernetes中的身份分为两种：用户身份和服务账号身份。服务账号由Kubernetes本身创建和管理，通常集群中运行的集群中运行的组件会关联到服务账号。而用户账号指的是所有其他与集群的实际用户相关联的账号，通常包括在集群外部运行的自动化服务。
5. Kubernetes提供了一个通用接口，供身份验证提供程序使用。每个提供程序都需要提供一个用户名，以及用户所属的组（可选）。
6. 角色是语族抽象能力的集合。而角色绑定是指将角色分配给一个或多个身份。
7. 在Kubernetes中，代表角色和角色绑定的资源有两种：一对仅适用于命名空间（Role和RoleBingding）；另一对适用于整个集群（ClusterRole和ClusterRoleBinding）。
8. Role资源带有命名空间，表示这个命名空间中的能力。你不能将命名空间的角色赋予非命名空间的资源。
9. 使用kubectl get clusterroles查看内置集群角色。
10. 尽管这些内置的角色大多数面向的是系统实用程序，但其中有四对是针对一般用户设计的：
    1. cluster-admin角色：提供整个集群完整的访问权限
    2. admin角色：提供整个命名空间完整的访问权限
    3. edit角色：允许用户修改命名空间中的一切
    4. view角色：提供命名空间的只读权限
11. 可以通过kubectl get clusterrolebingdings查看这些绑定
12. 针对集群内置角色做出的修改只是暂时的，一旦API服务器重启（例如升级等），你的修改就会被覆盖。需要将rbac.authorization.kubernetes.io/autoupdate注释添加到ClusterRole资源，并将值设置为false。如果这个注释为法拉瑟，则API服务器不会覆盖已修改的ClusterRole资源。
13. 在默认情况下，Kubernetes API服务器会安装一个集群角色，允许system:unauthenticated用户访问API服务i去的API发现端点。对于任何可能暴露到恶意环境的集群来说，这都不是一个好主意，应该确保API服务器设置了--anonymous-auth=false标志。
14. kubectl的auth can-i命令可以测试某个特定用户是否可以执行某个特定动作，可以使用--subresource命令行标志来测试日志或端口转发之类的子资源。
15. kubectl命令行工具提供了一个reconcile命令，该命令的操作有点像kubectl apply，太科研让一组用文本表示的角色和角色绑定与集群的当前状态保持一致。
16. Kubernetes RBAC支持使用聚合规则将多个角色组合在一起形成一个新的角色。这个新角色不仅集合了所有角色的功能，而且任何子角色的变化都会自动传播回这个聚合角色。
17. 需要使用标签选择器指定要聚合的ClusterRole。在这种特殊的情况下，ClusterRole资源中的aggregationRule字段包含一个clusterRoleSelector字段，而这个字段就是标签选择器。所欲与该选择器匹配的ClusterRole资源都将动态聚合到聚合ClusterRoler资源的rules列表中。
18. 在管理大量隶属于不同组织却拥有相似集群访问权限的人员时，通常最佳做法是使用组来管理定义集群访问权限的角色。
19. 如果想将组绑定到ClusterRole，则可以在绑定中指定subject的kind为Group。