## 第五章

1. 索引（在MySQL中也叫做“键”）是存储在用于快速找到记录的一种数据结构。
2. 索引可以包含一个或者多个列的值。如果索引包含多个列，那么列的顺序也十分重要，因为MySQL只能高效地使用索引的最左前缀。
3. 在MySQL中，索引是存储引擎层而不是服务器层实现的。所以，并没有统一的标准：不同存储引擎的索引的工作方式不一样，也不是索引的存储引擎都支持索引类型的索引。
4. 索引如果没有特别指明，那多半说的是B-Tree索引（B+Tree）。
5. MyISAM使用前缀压缩技术使得索引更小，但InnoDB则按照原数据格式进行存储。MyISAM索引通过数据的物理位置引用被索引的行，而InnoDB则根据主键引用被索引的行。
6. B-Tree通常意味着所有的值都是按顺序存储的，并且每一个叶子页到根的距离相同。
7. B-Tree索引能够加快访问数据的速度，因为存储引擎不再需要进行全表扫描来获取需要的数据，取而代之的是从索引的根结点开始进行搜索。根结点的槽中存放了指向子节点的指针，存储引擎根据这些指针向下层查找。通过比较节点页的值和要查找的值可以找到合适的指针进入下层子节点，这些指针实际上定义了子节点页中值的上限和下限，最终存储引擎要么是找到对应的值，要么该记录不存在。
8. 叶子节点比较特别，它们的指针指向的是被索引的数据，而不是其他的子节点。B-Tree对索引列是顺序组织存储的，所以很适合查找范围数据。
9. 索引对多个值进行排序的依据是CREATE TABLE语句中定义索引时列的顺序。
10. B-Tree索引适合用于全键值、键值范围或键前缀查找。其中键前缀查找只适用于最左前缀查找。
    1. 全值匹配：和索引中所有列进行匹配。
    2. 匹配最左前缀。
    3. 匹配列前缀：可以只匹配某一列的值的开头部分。
    4. 匹配范围值。
    5. 精确匹配某一列并范围匹配另外一对。
11. 除了按值查找之外，索引还可以用于查询中的ORDER BY操作（按顺序查找）。
12. B-Tree索引的限制：
    1. 如果不是按照索引的最左列开始查找，则无法使用索引。
    2. 不能跳过索引中的列。
    3. 如果查询中有某个列的范围查询，则其右边的所有列都无法使用索引优化查找。
13. 哈希索引基于哈希表实现，只有精确匹配索引所有列的查询才有效。对于每一行数据，存储引擎都会对所有的索引计算一个哈希码，哈希码是一个较小的值，并且不同键值的行间算出来的哈希码也不一样。哈希索引将所有的哈希码存储在索引中，同时在哈希表中保存指向每个数据行的指针。
14. 在MySQL中，只有Memory引擎显式支持哈希索引。这也是Memory引擎表的默认索引类型，Memory引擎同时也支持B-Tree索引。值得一提的是，Memory引擎是支持非唯一哈希索引的。
15. 哈希索引的限制：
    1. 哈希索引只包含哈希值和行指针，而不存储字段值，所以不能使用索引中的值来避免读取行。
    2. 哈希索引数据并不是按照值顺序存储的，所以也就无法用于排序。
    3. 哈希索引也不支持部分索引列匹配查找，因为哈希索引始终是使用索引列的全部内容来计算哈希值的。
    4. 哈希索引只支持等值比较查询。
    5. 访问哈希索引的数据非常快，除非有很多哈希冲突。当出现哈希冲突的时候，存储引擎必须遍历链表中所有的行指针，逐个进行比较，直到找到所有符合条件的行。
    6. 如果哈希冲突很多的话，一些索引维护操作的代价也会很高。
16. 除了Memory引擎外，NDB集群存储引擎也支持唯一哈希索引。
17. InnoDB引擎有一个特殊的功能叫做“自适应哈希索引”。当InnoDB注意到某些索引的值被使用得非常频繁时，他会在内存中基于B-Tree索引之上再创建一个哈希索引，这样就让B-Tree索引也具有哈希索引的一些优点，比如快速的哈希查找。
18. 当使用哈希索引进行查询的时候，必须在WHERE子句中包含常量值。
19. MyISAM表支持空间索引，可以用作地理数据存储。和B-Tree索引不同，这类索引无须前缀查询。空间索引会从所有维度来索引数据。查询时，可以有效地使用任意维度来组合查询。必须使用MySQL的GIS相关函数来维护数据。
20. 全文索引是一种特殊类型的索引，它查找的是文本中的关键词，而不是直接比较索引中的值。
21. 索引可以让服务器快速地定位到表的指定位置。但这并不是索引的唯一作用，总结下来索引有以下三个优点：
    1. 索引大大减少了服务器需要扫描的数据量。
    2. 索引可以帮助服务器避免排序和临时表。
    3. 索引可以将随机I/O变为顺序I/O.
22. 一个索引是否适合某个查询的“三星系统”：索引将相关的记录放到一起则获得一星；如果索引中的数据顺序和查找中的排列顺序一致则获得二星；如果索引中的列包含了查询中需要的全部列则获得“三星”。
23. 如果查询中的列不是独立的，则MySQL就不会使用索引。“独立的列”是指索引列不能是表达式的一部分，也不能是函数的参数。
24. 通常可以索引开始的部分字符，这样可以大大节约索引的空间，从而提高索引的效率。但这样也会降低索引的选择性。索引的选择性是指，不重复的索引值和数据表的总记录数的比值，范围从1/N到1之间。索引的选择性越高则查询效率越高，因为选择性高的索引可以让MySQL在查找时过滤掉更多的行。唯一索引的选择性是1，这是最好的索引选择性，性能也是最好的。
25. 对于BLOB、TEXT或者很长的VARCHAR类型的列，必须使用前缀索引，因为MySQL不允许索引这些列的完整长度
26. 前缀索引是一种能使索引更小、更快的有效办法，但另一方面也有其缺点：MySQL无法使用前缀索引做ORDER BY和GROUP BY，也无法使用前缀索引做覆盖扫描。
27. MySQL5.0以上版本引入了一种叫“索引合并”的策略，一定程度上可以使用表上的多个单列索引来定位指定的行。
28. 当出现服务器对多个索引做相交操作时（通常有多个AND条件），通常意味着需要包含所有相关列的多列索引，而不是多个独立的单列索引。
29. 当服务器需要对多个索引做联合操作时（通常有多个OR）条件，通常需要耗费大量CPU和内存资源在算法的缓存、排序和合并操作上。特别是当其中有些索引的选择性不高，需要合并扫描返回的大量数据的时候。
30. 优化器不会把这些计算到“查询成本”中，优化器只关心随机页面读取。这会使得查询的成本被“低估”，导致该执行计划还不如直接走全表扫描。
31. 可以通过参数optimizer_switch来关闭索引合并的功能。
32. 可以使用IGNORE INDEX提示让优化器忽略掉某些索引。
33. 在一个多列B-Tree中，索引列的顺序意味着索引首先按照最左列进行排序，其次是第二列，等等。
34. 索引可以按照升序或者降序扫描，以满足精确符合列顺序的ORDER BY、GROUP BY和DISTINCE等子句的查询要求。
35. 选择索引列顺序的一个经验法则：将选择性最高的列放到索引列的最前列，这样设计的索引能够最快地过滤出需要的行
36. 聚簇索引并不是一种单独的索引类型，而是一种数据存储方式。InnoDB的聚簇索引实际上在同一个结构中保存了B-Tree索引和数据行。
37. 当表有聚簇索引时，它的数据行实际上存放在索引的叶子页中。术语“聚簇”表示数据行和相邻的键值紧凑的存储在一起。因为无法同时把数据行存放在两个不同的地方，所以一个表只能有一个聚簇索引。
38. InnoDB通过主键聚集数据。
39. 如果没有定义主键，InnoDB会选择一个唯一的非空索引代替。如果没有这样的索引，InnoDB会隐式定义一个主键来作为聚簇索引。InnoDB只聚集在同一个页面中的记录。包含相邻键值的页面可能会相距甚远。
40. 聚簇索引优点：
    1. 可以把相关数据保存在一起。
    2. 数据访问更快。聚簇索引将索引和数据保存在同一个B-Tree中，因此从聚簇索引中获取数据通常比在非聚簇索引中查找要快。
    3. 使用覆盖索引扫描的查询可以直接使用页节点中的主键值。
41. 聚簇索引的缺点：
    1. 聚簇数据最大限度地提高了I/O密集型应用的性能，但如果数据全部存放在内存中，则访问的顺序就没有那么重要了，聚簇索引也就没什么优势了。
    2. 插入速度严重依赖于插入顺序。按照主键的顺序插入是加载数据到InnoDB表中速度最快的方式。但如果不是按照主键顺序加载数据，那么在加载完成之后最好使用OPTIMIZE TABLE命令重新组织一下表。
    3. 更新聚簇索引列的代价很高，因为会强制InnoDB将每个被更新的行移动到新的位置。
    4. 基于聚簇索引的表在插入新行，或者主键被更新导致需要移动行的时候，可能面临“页分裂”的问题。
    5. 聚簇索引可能导致全表扫描变慢，尤其是行比较稀疏，或者是由于页分裂导致数据存储不连续的时候。
    6. 二级索引（非聚簇索引）可能比想象中的要更大，因为在二级索引的叶子节点包含了引用行的主键列。
    7. 二级索引访问需要两次索引查找，而不是一次。
42. 二级索引中保存的“行指针”的实质是行的主键值，这意味着通过二级索引查找的行，存储引擎需要找到二级索引的叶子节点获得对应的主键值，然后根据这个主键值去聚簇索引中查找到对应的行。
43. MyISAM按照数据插入的顺序存储在磁盘上。事实上，MyISAM中主键索引和其他索引在结构上没有什么不同。主键索引就是一个名为PRIMARY的唯一非空索引。
44. 在InnoDB中，聚簇索引就是表，所以不需要像MyISAM那样需要独立的行存储。
45. 聚簇索引的每一个叶子节点都包含了主键值、事务ID、用于事物和MVCC的回滚指针以及所有的剩余列。如果主键是一个列前缀索引，InnoDB也会包含完整的主键列和剩下的其他列。
46. InnoDB的二级索引和聚簇索引很不同。InnoDB二级索引的叶子节点中存储的不是“行指针”。而是主键值，并以此作为指向行的“指针”。
47. 如果正在使用InnoDB表并没有什么数据需要聚集，那么可以定义一个代理键作为主键，这种主键的数据应该和应用无关，最简单的方法是使用AUTO_INCREMENT自增列。这样可以保证数据行是按顺序写入，对于根据主键做关联操作的性能也会更好。
48. 当达到页的最大填充因子（InnoDB默认页大小为16KB，最大填充因子是页大小的15/16，留出部分空间用于以后的修改），下一条记录就会写入新的页中。
49. 在InnoDB如果不是按顺序插入新行，则可能造成：
    1. 写入的目标页可能已经刷到磁盘上并从缓存中移除，或者是还没有被加载到缓存中，InnoDB在插入之前不得不先找到并从磁盘读取目标页到内存中。这将导致大量的随机I/O。
    2. 因为写入是乱序的，InnoDB不得不频繁地做页分裂操作，以便为新的行分配空间。页分裂会导致移动大量数据，一次插入最少需要修改三个页而不是一个页。
    3. 由于频繁的页分裂，页会变得稀疏并被不规则地填充，所以最终会有碎片。
50. 使用InnoDB时应该尽可能地按主键顺序插入数据，并且尽可能地使用单调增加地聚簇键的值来插入新行。
51. 如果一个索引包含（或者说覆盖）所有需要查询的字段的值，我们就称之为“覆盖索引”。优点：
    1. 索引条目通常远小于数据行大小，所以如果只需要读取索引，那MySQL就会极大地减少数据访问量。
    2. 因为索引是按照列值顺序存储的，所以对于I/O密集型的范围查询会比随机从磁盘读取每一行数据的I/O要少得多。
    3. 一些存储引擎如MyISAM在内存中只缓存索引，数据则依赖于操作系统来做缓存，因此要访问数据就需要一次系统调用。
    4. 有毒InnoDB的聚簇索引，覆盖索引对InnoDB表特别有用。InnoDB对二级索引在叶子节点中保存了行的主键值，所以如果二级逐渐能够覆盖查询，则可以避免对主键索引的二次查询。
52. 不是所有类型的索引都可以成为覆盖索引。覆盖索引必须要存储索引列的值，二哈希索引、空间索引和全文索引等都不存储索引列的值，所以MySQL只能使用B-Tree索引做覆盖索引。
53. MySQL有两种方式可以生成有序的结果：通过排序操作，或者按索引顺序扫描。如果EXPLAIN出来的type列的值为“index”，则说明MySQL使用了索引扫描来做排序。
54. 如果索引不能覆盖查询所需的全部列，那就不得不每扫描一条索引记录就都回表查询一次对应的行。这基本上都是随机I/O，因此按索引顺序读取数据的速度通常要比顺序地全表扫描慢。
55. MySQL可以使用同一个索引既满足排序，有用于查找行。因此，如果可能，设计索引时应该尽可能地同时满足这两种任务。
56. 只有当索引的列顺序和ORDER BY子句的顺序完全一致，并且所有列的排序方向（倒序或正序）都一样时mMySQL才能够使用索引来对结果做排序，如果查询需要关联多张表，则只有当ORDER BY子句引用的字段全部为第一个表时，才能使用索引做排序。
57. 有一种情况下ORDER BY子句可以不满足索引的最左前缀的要求，就是前导列卫常量的时候。
58. MyISAM使用前缀压缩来减少索引的大小，从而让更多的索引可以放入内存中，这在某些情况下能极大地提高性能。默认值压缩字符串，但通过参数设置也可以对整数做压缩。MyISAM压缩每个索引块的方法是，先完全保存索引块中的第一个值，然后将其他值和第一个值进行比较得到相同前缀的字节数和剩余的不同后缀部分。MyISAM对行指针也采用类似的前缀压缩方式。
59. MySQL允许在相同列上创建多个索引，无论是有意还是无意的。MySQL需要单独维护重复的索引，并且优化器在优化查询的时候也需要逐个地进行考虑。
60. 重复索引是指在相同的列上按照相同的顺序创建的相同类型的索引。
61. 冗余索引是指，如果创建了索引（A，B），再创建索引（A）就是冗余索引，因为这只是前一个索引的前缀索引。
62. 可以打开userstates服务器变量（默认是关闭的），然后让服务器正常运行一段时间，再通过查询INFORMATION_SCHEMA.INDEX_STATISTICS就能查到每个索引的使用率。
63. 索引可以让查询锁定更少的行。
64. InnoDB只有在访问行的时候才会对其加锁，而索引能够减少InnoDB访问的行数，从而减少锁的数量。但这只有当InnoDB在存储引擎层能够过滤掉所有不需要的行时才有效。如果索引无法过滤掉无效的行，那么在InnoDB检索到数据并返回给服务器层后，MySQL服务器才能应用WHERE子句。这时已经无法避免锁定行：InnoDB已经锁住了这些行，到适当的时候才释放。在MySQL5.1和更新的版本中，InnoDB可以在服务器过滤掉行后就释放锁，但是在早起的MySQL版本中，InnoDB只有在事务提交后才能释放锁。
65. InnoDB在二级索引上使用共享（读）锁，但访问主键索引需要排它（写）锁。
66. 对于范围条件查询，MySQL无法再使用范围列后面的其他索引列了，但是对于“多个等值条件查询”（IN()）则没有这个限制。
67. 对于那些选择性非常低的列，可以增加一些特殊的索引来做排序。
68. 即使使用了正确的类型创建了表并加上了合适的索引，工作也没有结束：还需要维护表和索引来确保它们都正常工作。维护表有三个主要的目的：找到并修复损坏的表，维护准确的索引统计信息，减少碎片。
69. 可以尝试运行CHECK TABLE来检查是否发生了表损坏（注意：有些存储引擎不支持该命令；而有些引擎则支持以不同的选项来控制完全检查表的方式）。
70. 可以使用REPAIR TABLE命令来修复损坏的表。
71. 如果InnoDB引擎的表出现了损坏，那么一定是发生了严重的错误，需要立刻调查一下原因。InnoDB一般不会出现损坏。InnoDB的设计保证了它并不容易被损坏。如果发生了损坏，一般要么是数据库的硬件问题如内存或者磁盘问题，要么是由于数据库管理员的错误，抑或是InnoDB本身的缺陷（不太可能）。
72. 可以通过设置innodb_force_recovery参数进入InnoDB的强制恢复模式来修复数据。
73. MySQL的查询优化器会通过连个API来了解存储引擎的索引值的分布信息，以决定如何使用索引。第一个API是records_in_range()，通过向存储引擎传入两个边界值获取在这这个范围大概有多少条记录。对于某些存储引擎，该接口返回精确值。
74. 第二个API是info()，该接口返回各种类型的数据，包括索引的基数。
75. 如果存储引擎向优化器提高的扫描行数信息是不准确的数据，或者执行计划本身太复杂以致于无法准确地获取各个阶段匹配的行数，那么优化器会使用索引统计信息来估算扫描的行数。MySQL优化器使用的是基于成本的模型，而衡量成本的主要指标就是一个查询需要扫描多少行。
76. 可以运行ANALYZE TABLE来重新生成统计信息。
77. 每种存储引擎统计信息的方式不同，所以需要进行ANALYZE TABLE的频率也因不同的引擎而不同，每次运行的成本也不同：
    1. Memory引擎不存储索引统计信息。
    2. MyISAM将索引统计信息存储在磁盘中，ANALYZE TABLE需要进行一次全索引扫描来计算索引的基数。在整个过程中需要锁表。
    3. 直到MySQL5.5版本，InnoDB也不再磁盘存储引擎统计信息，而是通过随机的索引访问进行评估将其存储在内存中。
78. 可以使用SHOW INDEX FROM 命令来查看索引的基数。
79. InnoDB引擎通过抽样的方式来计算统计信息，首先随机地读取少量的索引页面，然后以此为样本计算索引的统计信息。
80. 在老的InnoDB版本中，样本页面数是8，新版本的InnoDB可以通过innodb_stats_sample_pages来设置样本页的数量。
81. InnoDB会在表首次打开，或者执行ANALYZE TABLE，抑或表的大小发生非常大的变化（大小变化超过十六分之一或者新插入了20亿行都会触发）的时候计算索引的统计信息。
82. InnoDB再打开某些INFOMATION_SCHEMA表，或者使用SHOW TABLE STATUS和SHOW INDEX，抑或在MySQL客户端开启自动补全功能的时候都会触发索引统计信息的更新。
83. 如果使用Percona版本，使用的就是XtraDB引擎而不是原生的InnoDB引擎，那么可以通过innodb_stats_auto_update参数来禁止通过自动采样的方式更新索引的统计信息，这时需要手动执行ANALYZE TABLE命令来手动更新统计信息。
84. B-Tree索引可能会碎片化，这会降低查询的效率。碎片化的索引可能会以很差或者无序的方式存储在磁盘上。
85. 表的数据存储也可能碎片化，有三种类型的数据碎片：
    1. 行碎片：这种碎片指的是数据行被存储为多个地方的多个片段中。即使查询只从索引中访问一行记录，行碎片也会导致性能下降。
    2. 行间碎片：指逻辑上顺序的页，或者在磁盘上不是顺序存储的。行间碎片对诸如全表扫描和聚簇索引扫描之类的操作有很大影响，因为这些操作原本能够从磁盘上顺序存储的数据中获益。
    3. 剩余空间碎片：指数据页中有大量的剩余空间。这会导致服务器读取大量不需要的数据，从而造成浪费。
86. 对于MyISAM表，这三类碎片化都可能发生。但InnoDB不会出现短小的行碎片，InnoDB会移动短小的行并重写到一个片段中。
