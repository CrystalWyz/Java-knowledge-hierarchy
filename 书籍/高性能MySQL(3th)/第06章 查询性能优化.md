## 第六章 查询性能优化

1. 查询的生命周期：客户端 -> 服务器（解析，生成执行计划，执行并返回结果）
2. 查询性能低下的根本原因是访问的数据太多。对于低效的查询，通过下面两个步骤来分析总是很有效的：
   1. 确认应用程序是否在检索大量超过需要的数据。通常意味着访问了太多的行，但有时候也可能是访问了太多的列。
   2. 确认MySQL服务器是否在分析大量超过需要的数据行。
3. 一个常见的错误是常常会误以为MySQL会只返回需要的数据，实际上MySQL却是先返回全部结果集在进行计算。
4. 最简单和衡量查询开销的三个指标：响应时间、扫描的行数和返回的行数。这三个指标都会记录到MySQL的慢查询日志中，所以检查慢查询日志记录是赵处扫描行数过多的查询的好办法。
5. 响应时间是两个部分之和：服务时间和排队时间。服务时间是指数据库处理这个查询真正花了多长时间。排队时间是指服务器因为等待某些资源而没有真正执行查询的时间。
6. 分析查询时，查看该查询扫描的行数是非常有效的。这在一定程度上说明该查询找到需要的数据的效率。
7. 在评估查询开销的时候，需要考虑一下从表中找到某一行数据的成本。MySQL有好几种访问方式可以查找并返回一行结果。有些访问方式可能需要扫描很多行才能返回一行结果，也有些访问方式可能无需扫描就能返回结果。
8. 在EXPLAIN语句中的type列反应了返回类型。
9. 一般MySQL能够使用如下三种方式应用WHERE条件，从好到坏依次为：
   1. 在索引中使用WHERE条件来过滤不匹配的记录。这是在存储引擎层完成的。
   2. 使用索引覆盖扫描（在Extra列中出现了Using index）来返回记录，直接从索引中过滤不需要的记录并返回命中的结果。这是在MySQL服务器层完成的，但无需回表查询记录。
   3. 从数据表中返回数据，然后过滤不满足条件的记录。这在MySQL服务器层完成的，MySQL需要先从数据表读出记录然后过滤。
10. MySQL不会告诉我们生结果实际上需要扫描多少行记录，而只会告诉我们生成结果时一共扫描了多少行记录。
11. 如果发现查询需要扫描大量的数据但只返回了少数的行，那么通常可以尝试下面的技巧去优化它：
    1. 使用索引覆盖扫描，把所有需要用的列都放到索引中，这样存储引擎无须回表获取对应行就能返回结果。
    2. 改变库表结构。
    3. 重写这个复杂的查询，让MySQL优化器能够以更优化的方式执行这个查询。
12. MySQL从设计上让连接和断开列姐都很轻量级，在返回一个小的查询结果方面很高效。
13. 有时候对于一个大查询我们需要“分而治之”，将大查询切分成小查询，每个查询功能完全一样，只完成一小部分，每次只返回一小部分查询结果。
14. 很多高性能的应用都会对关联查询进行分解，用分解关联查询的方式重构查询有以下优势：
    1. 让缓存的效率更高。需要应用程序可以方便地缓存但表查询对于地结果对象。
    2. 将查询分解后，执行单个查询可以减少锁的竞争。
    3. 在应用层做关联，可以更容易对数据库进行拆分，更容易做到高性能和可扩展。
    4. 查询本身效率也可能会有所提升。
    5. 可以减少冗余记录到查询。
    6. 更进一步，这样做相当于在应用中实现了哈希关联，而不是使用MySQL对嵌套循环关联。
15. 查询的生命周期：
    1. 客户发送一条查询给服务器。
    2. 服务器先检查查询缓存，如果命中了缓存，则立刻返回存储在缓存中的结果。否则进入下一个阶段。
    3. 服务器端进行SQL解析、预处理、再由优化器生成对应的执行计划。
    4. MySQL根据优化器生成的执行计划，调用存储引擎的API来执行查询。
    5. 将结果返回给客户端。
16. MySQL客户端和服务器之间的通信协议是“半双工的”，这意味着，在任何一个时刻，要么是由服务器向客户端发送数据，要么是由客户端向服务器发送数据，这两个动作不能同时发生。这种协议让MySQL通信简单快速，但是也从很多地方限制了MySQ。一个明显的限制是，这意味着没法进行流量控制。一旦一段开始发送消息，另一端要接收完整消息才能响应它。
17. 客户端用一个单独的数据包将查询传送给服务器。这也是为什么当查询的语句很长的时候，参数max_allowed_packet就特别重要了。如果查询太大，服务器会拒绝接受更多的数据并抛出相应的错误。
18. 当服务器开始响应客户端请求时，客户端必须完整地接收整个返回的结果，而不能简单地只取前面几条结果，然后让服务器停止发送数据。
19. 默认一般是获得全部结果集并缓存到内存中。MySQL通常需要等所有的数据都已经发送给客户端才能释放这条查询所占用的资源，所以接受全部结果并缓存通常可以减少服务器的压力，让查询能够早点结束、早点释放相应的资源。
20. 当使用多数连接MySQL的库函数从MySQL获取数据时，其结果看起来都像是从MySQL服务器获取数据，而实际上都是从这个库函数的缓存获取数据。
21. 指定mysql_use_result属性为1，将直接“使用”返回的结果而不会将其缓存。
22. 有很多方式能查看当前的状态，最简单的是使用SHOW FULL PROCESSLIST命令（该命令返回结果中的Command列就表示当前的状态）。
23. 查询状态解释：
    1. Sleep：线程正在等待客户端发送新的请求。
    2. Query：线程正在执行查询或者正在将结果发送给客户端。
    3. Locked：在MySQL服务器层，该线程正在等待表锁。在存储引擎级别实现的锁，例如InnoDB的行锁，并不会体现在线程状态中。对于MyISAM来说这是一个比较典型的状态，但在其他没有行锁的引擎中也经常会出现。
    4. Analyzing、statistics：线程正在收集存储引擎的统计信息，并生成查询的执行计划。
    5. Copying and tmp table [on disk]：线程正在执行查询，并且将其结果都复制到一个临时表中，这种状态一般要么是在做GROUP BY操作，要么是文件排序操作，或者是UNION操作。如果这个状态后面还有“on disk”标记，那表示MySQL正在将一个内存临时表放到磁盘上。
    6. Sorting result：线程正在对结果进行排序操作。
    7. Sending data：这表示多种情况：线程可能在多个状态之间传送数据，或者在生成结果集，或者向客户端返回数据。
24. 在解析一个查询语句之前，如果查询缓存是打开的，那么MySQL会优先检查这个查询是否命中查询缓存中的数据。这个检查是通过一个对大小写敏感的哈希查找实现的。插叙和缓存中的查询即使只有一个字节不同，那也不会匹配缓存结果，这种情况下查询就会进入下一阶段的处理。
25. 如果当前的查询恰好命中了查询缓存，那么在返回查询结果之前MySQL会检查一次用户权限。如果权限没有问题，MySQL会跳过所有其他阶段，直接从缓存中拿到结果并返回给客户端。
26. 查询的生命周期的下一步是将一个SQL转换成一个执行计划，MySQL再依照这个执行计划和存储引擎进行交互。这包括多个子阶段：解析SQL、预处理、优化SQL执行计划。
27. 首先，MySQL通过关键字将SQL语句进行解析，并生成一颗对应的“解析树”。MySQL解析器将使用MySQL语法规则验证和解析查询。
28. 预处理则根据一些MySQL规则进一步检查解析树是否合法。下一步预处理会验证权限。
29. 当语法书被认为是合法的之后，优化器将其转换成执行计划。一条查询可以有很多种执行方式，最后都会返回相同的结果。优化器的作用就是找到这其中最好的执行计划。
30. MySQL使用基于成本的优化器，它将会查实预测一个查询使用某种执行计划时的成本，并选择其中一个成本最小的一个。可以同查询当前会话的Last_query_cost值来得知MySQL计算当前查询的成本。
31. 优化器在评估成本的时候并不考虑任何层面的缓存，他假设读取任何数据都需要一次磁盘I/O。
32. 有很多种原因会导致MySQL优化器选择错误的执行计划：
    1. 统计信息不准确。MySQL依赖存储引擎提供的统计信息来评估成本，但是有的存储引擎提供的信息是准确的，有的偏差可能非常大。
    2. 执行计划中的成本估算不等同于实际执行成本。所以即使统计信息精准，优化器给出的执行计划也可能不是最优的。
    3. MySQL的最优可能和你想的最优不一样。你可能希望执行时间尽可能的短，但是MySQL只是基于成本模型选择最优的执行计划，而有些时候这并不是最快的执行方式。
    4. MySQL从不考虑其他并发执行的查询，这可能会影响到当前查询到速度。
    5. MySQL也并不是任何时候都是基于成本的优化。有时也会基于一些固定的规则，例如，如果存在全文搜索的MATCH()子句，则在存在全文索引的时候就使用全文索引。
    6. MySQL不会考虑不受其控制的操作成本，例如执行存储过程或者用户自定义函数的成本。
    7. 优化器有时候无法估算所有可能的执行计划，所以他可能错过实际上最优的执行计划。
33. MySQL的查询优化器是一个非常复杂的查询部件，他使用了很多优化策略来生成一个最优的执行计划。优化策略可以简单地分为两种，一种是静态优化，一种是动态优化。
34. 静态优化可以直接对解析树进行分析，并完成优化。静态优化在第一次完成后就一直有效，即使使用不同的参数重复执行查询也不会发生任何变化。
35. 动态优化则和查询的上下文有关，也可能和很多其他因素有关，例如WHERE条件中的取值、索引中条目对应的数据行数等。这需要在每次查询等时候都重新评估，可以认为这是“运行时优化”。
36. 在执行语句和存储过程都时候，动态优化和静态优化的区别非常重要。MySQL对查询的静态优化只需要做一次，但对查询的动态优化则在每次执行都需要重新评估。有时候甚至在查询的执行过程中也会重新优化。
37. MySQL能够处理的优化类型：
    1. 重新定义关联表的顺序：数据表的关联并不总是按照在查询中指定的顺序进行。
    2. 将外连接转换为内连接：并不是所有的OUTER JOIN语句都必须以外连接的方式执行。诸多因素，例如WHERE条件、库表结构都困难会让外连接等价于一个内连接。MySQL能够识别这点并重写查询，让其可以调整关联顺序。
    3. 使用等价变换原则：MySQL可以使用一些等价变换来简化并规范表达式。它可以合并和减少一些比较，还可以移除一些恒成立和一些恒不成立的判断。
    4. 优化COUNT()、MIN()、MAX()：索引和列是否可为通常可以帮助MySQL优化这类表达式。如果MySQL使用了这种类型的优化，那么在EXPLAIN中可以看到“Select tables optimized away”。
    5. 预估并转化为常数表达式：当MySQL监测到一个表达式可以转化为常数的时候，就会一直把该表达式做为常数进行优化处理。在优化阶段，有时候甚至一个查询也能够转化为一个常数。
    6. 覆盖索引扫描：当索引中包含所有查询中需要使用的列的时候，MySQL就可以使用索引返回需要的数据，而无序查询对应的数据行。
    7. 子查询优化：MySQL在某些情况下可以将子查询转换成一种效率更高的形式，从而减少多个查询多次对数据进行访问。
    8. 提前终止查询：在发现已经满足查询需求的时候，MySQL总是能够立刻终止查询。
    9. 等值传播：如果两个列的值通过等式关联，那么MySQL能够把其中一个列的WHERE条件传递到另一个上。
    10. 列表IN()的比较：在很多数据库系统中，IN()完全等价于多个OR条件的子句，因为这两者是完全等价的。在MySQL中这点事不成立的，MySQL将IN()列表中的数据先进行排序，然后通过二分查找的方式来确定列表中的值是否满足条件，这是一个O(logn)复杂度的操作，等价地转换成OR查询的复杂度为O(n)。
38. 因为服务器层没有任何统计信息，所以MySQL查询优惠券在生成查询的执行计划时，需要想存储引擎获取相应的统计信息。
39. MySQL中“关联”一次所包含的意义比一般意义上理解的要更广泛。总的来说，MySQL认为任何一个查询都是一次“关联”——并不仅仅是一个查询需要到两个表匹配才叫关联。
40. 对于UNION查询，MySQL先将一系列的单个查询结果放到一个临时表中，然后再重新读取临时表数据来完成UNION查询。
41. 当前MySQL关联执行的策略很简单：MySQL对任何关联都执行嵌套循环关联操作，即MySQL现在一个表中循环取出单条数据，然喝再潜逃循环到下一个表中寻找匹配到行，依次下去，直到找到所有表中匹配到行为止。然后根据各个表匹配到行，返回查询中需要的各个列。MySQL会尝试在最后一个关联表中找到所有匹配的行，如果最后一个关联表无法找到更多的行以后，MySQL返回到上一层次的关联表，看是否能找到更多的匹配记录，以此类推迭代进行。
42. 从本质上来说，MySQL对所有的类型的查询都以同样的方式运行。例如，MySQL在FROM子句中遇到子查询时，先执行子查询并将其结果放到一个临时表中，然后将这个临时表当做一个普通表对待。MySQL在执行UNION查询时也使用类似的临时表，在遇到右外连接的时候，MySQL将其改写成等价的左外连接。
43. 和很多其他关系数据库不同，MySQL并不会生成查询字节码来执行查询。MySQL生成查询的一颗指令树，然后通过存储引擎完成这颗指令树并返回结果。如果对某个查询执行EXPLAIN EXTENDED后，再执行SHOW WARNINGS，就可以看到重构出的查询。
44. MySQL优化器最重要的一部分就是关联查询的优化，它决定了多个表关联时的顺序。通常多表关联的时候，可以有多种不同的关联顺序来获得相同的执行结果。关联查询优化器则通过评估不同顺序的成本来选择一个代价最小的关联顺序。
45. STRAIGHT_JOIN可以让优化器按照你认为的最优的关联顺序执行。
46. 如果有哪个表的关联，那么需要检查n的阶乘种关联顺序。我们称之为所有可能的执行计划的“搜索空间”，搜索空间的增长速度非常快。
47. 当搜索空间非常大的时候，优化器不可能逐一评估每一种关联顺序的成本。这时，优化器选择使用“贪婪”搜索的方式查找“最优”的关联顺序。实际上，当需要关联的表超过optimizer_search_depth的限制的时候，就会选择“贪婪”搜索模式了。
48. 无论如何排序都是一个成本很高的操作，所以从性能角度考虑，应尽可能避免排序或者尽可能避免对大量数据进行排序操作。
49. 如果需要排序的数据量小于“排序缓冲区”，MySQL使用内存进行“快速排序”操作。如果内存不够排序，那么MySQL会先将数据分块，对每个独立的块使用“快速排序：进行排序，并将各个块的排序结果存放在磁盘上，然后将各个排好序的块进行合并，最后返回排序结果。
50. MySQL有如下两种排序算法：
    1. 两次传输排序：读取行指针和需要排序的字段，对其进行排序，然后再根据排序结果读取所需要的数据行。
    2. 单词传输排序：先读取查询所需要的所有列，然后在根据给定列进行排序，最后直接返回排序结果。这个算法只在MySQL4.1和后续更新版本才引入。当查询需要所有列的总长度不超过参数max_length_for_sort_data时，MySQL使用“单次传输排序”，可以通过调整这个参数来影响MySQL排序算法的选择。
51. MySQL在排序时，对每一个排序记录都会分配一个足够长的定长空间来存放。
52. 在关联查询的时候如果需要排序，MySQL会分两种情况来处理这样的文件排序。
53. 在关联查询的时候如果需要排序，MySQL会分两种情况来处理这样的文件排序。如果ORDER BY子句中的所有列都来自关联的第一个表，那么MySQL在关联处理第一个表的时候就进行文件排序。如果是这样，那么在MySQL的EXPLAIN结果中可以看到Extra字段有“Using filesort”。除此之外的所有情况，MySQL都会先将关联的结果存放到一个临时表中，然后在所有的关联都结束后，再进行文件排序。这种情况下，在MySQL的EXPLAIN结果的Extra字段可以看到“Using temporary，Using filesort”。如果查询中有LIMIT的话，LIMIT也会在排序之后应用，所以即使需要返回较少的数据，临时表和需要排序的数据量仍然会非常大。
54. 在解析和优化阶段，MySQL将生成查询对应的执行计划，MySQL的查询执行引擎则根据这个执行计划来完成整个查询。这里的执行计划是一个数据结构。
55. 在根据执行计划逐步执行的过程中，有大量的操作需要通过调用存储引擎实现的接口来完成，这些借口也就是我们称为“handler API”的接口。查询中的每一个表由一个handler的示例表示。
56. MySQL将结果集返回客户端一个增量、逐步返回的过程。
57. MySQL的子查询实现得非常糟糕。最糟糕的一类查询是WHERE条件中包含IN()从子查询语句。
58. 可以使用EXPLAIN TEXTENDED来查看查询被改写成什么样子。
59. 一旦使用了DISTINCE和GROUP BY，那么在查询的执行过程中，通常需要产生临时中间表。
60. 如果希望UNION的各个子句能够根据LIMIT只取部分结果集，或者希望能够先排好序再合并结果集的话，就需要在UNION的各个子句中分别使用这些子句。
61. 某些时候，等值传递会带来一些意想不到的额外消耗。
62. MySQL无法利用多核特性来并行执行查询。
63. MySQL并不支持哈希关联——MySQL的所有关联都是嵌套循环关联。
64. 由于历史原因，MySQL并不支持松散索引扫描，也就无法按照不连续的方式扫描一个索引。通常，MySQL的索引扫描需要先定义一个起点和终点，即使需要的数据只是这段索引中很少数的几个，MySQL仍需要扫描这段索引每一个条目。
65. MySQL不允许对同一张表同时进行查询和更新。（可以用临时表绕）
66. 如果对优化器选择的执行计划不满意，可以使用优化器提供的几个提示来控制最终的执行计划。通过在查询中加入相应的提示，就可以控制该查询的执行计划。
67. HIGH_PRIORITY用于SELECT语句的时候，MySQL会将此SELECT语句重新调度带所有正在等待表锁以便修改数据的语句之前。实际上MySQL是将其放在表带队列的最前面，而不是按照常规顺序等待。HIGH_PRIORITY还可以用于INSERT语句，其效果只是简单地抵消了全局LOW_PRIORITY设置对该语句的影响。
68. LOW_PRIORITY则正好相反：它会让语句一直处于等待状态，只要队列中还有需要访问同一个表的语句——即使是那些比该语句还晚提交到服务器的语句。
69. 这个两个提示只对使用表锁的存储引擎有效，千万不要用在InnoDB或者其他有细粒度所及之和并发控制的引擎中使用。即使是在MyISAM中使用也要注意，因为这两个提示会导致并发插入被禁用。
70. DELAYED：整体上对INSERT和REPLACE有效。mySQL会将使用该提示的语句立即返回给客户端，并将插入的行数据放到缓冲区，然后在表空闲的时将数据写入。
71. STRAIGHT_JOIN：这个提示可以放置在SELECT语句的SELECT关键字之后，也可以放置在任何两个关联表的名词之间。第一个用法是让查询中所有的表按照在语句中出现的顺序进行关联。第二个用法则是固定其前后两个表的关联顺序。
72. SQL_SMALL_RESULT 和 SQL_BIG_RESULT：这两个提示只对SELECT语句有效。它们告诉优化器对GROUP BY或者DISTINCE查询如何使用临时表及排序。SQL_SMALL_RESULT告诉优化器结果集会很小，可以将结果集放在内存中的索引临时表，以避免排序操作。如果是SQL_BIG_RESULT，则高速优化器结果集可能会很大，建议使用磁盘临时表做排序操作。
73. SQL_BUFFER_RESULT：这个提示告诉优化器将查询结果放入到一个临时表，然后尽可能快地释放表锁。
74. SQL_CACHE 和 SQL_NO_CACHE：这个提示告诉MySQL这个结果集是否应该缓存在查询缓存中。
75. SQL_CALC_FOUND_ROWS：它不会告诉优化器任何关于执行计划的东西，它会让MySQL返回的结果集包含更多的信息。查询中加上该提示MySQL会计算结果集。可以通过函数FOUND_ROW()获得这个值。
76. FOR UPDATE 和LOCK IN SHARE MODE：这两个提示主要控制SELECT语句的锁机制，但只对实现了行级锁的存储引擎有效。使用该提示会对符合查询条件的数据行加锁。对于INSERT...SELECT语句是不需要这两个提示的，因为MySQL5.0以后默认加上读锁。唯一内置的支持这两个提示的存储引擎就是InnoDB，这两个提示会让某些优化无法正常使用，如索引覆盖扫描。InnoDB不能在不访问主键的情况下排他地锁定行，因为行的版本信息保存在主键中。
77. USE INDEX、IGNORE INDEX、FORCE INDEX：这几个提示会告诉优化器使用或者不适应那些索引来查询记录，在MySQL5.1以后可以通过新增选项FOR RODER BY 和FOR GROUP BY 来制定是否对排序和分组有效。
78. 在MySQL5.0之后：
    1. optimizer_search_depth：控制优化器在穷举执行计划时的限度。
    2. optimizer_prune_level：这个参数默认时打开的，这让优化器会根据扫描的行数来决定是否跳过某些执行计划。
    3. optimizer_switch：这个变量包含了一些开启/关闭优化器特性的标识位。
79. COUNT()是一个特殊的函数，有两种非常不同的作用：他可以统计某个列值的数量，也可以统计行数。在统计列值时要求列值时非空的（不统计NULL）。如果在COUNT()的括号中制定了列或者列的表达式，则统计的就是这个表达式有值的结果输。
80. COUNT()的另一个作用时统计结果集的行数。当MySQL确认括号内的表达式值不可能为空时，实际上就是在统计行数。最简单的就是当我们使用COUNT(*)的时候，这种情况下通配符`*`并不会像我们才行的那样扩展成为所有列，实际上，它会忽略所有的列而直接统计所有行数。
81. MyISAM的COUNT()函数只有在没有任何WHERE调剂的COUNT(*)才非常快，因为此时无序实际地去计算表的行数。MySQL可以利用存储引擎的特性直接获得这个值。如果MySQL知道某个列col不可能为NULL值，那么MySQL内部会将COUNT(col)表达式优化为count(`*`)。
82. 有时候某些业务场景并不要求完全精确的COUNT()值，此时可以用近似值来代替。EXPLAIN出来的与欧华侨估算的行数就是一个不错的近似值，EXPLAIN并不需要真正地去执行查询，所以成本低。
83. 优化关联查询：
    1. 确保ON或者USING子句中的列上有索引。一般来说，除非有其他理由，否则只需要在关联顺序中的第二个表的相应列上创建索引。
    2. 确保任何的GROUP BY 和 ORDER BY中的表达式只涉及到一个表中的列。
84. 子查询优化尽可能使用关联查询代替。
85. 在MySQL中，当无法使用索引的时候，GROUP BY使用两种策略完成：使用临时表或者文件排序来做分组。可以通过使用提示SQL_SMALL_RESULT和SQL_BIG_RESULT来让优化器按照你希望的方式运行。
86. 如果需要对关联查询做分组，并且是按照查找表中的某个列进行分组，那么通常采用查找表的标识列分组的效率会比其他列更高。
87. 建议将MySQL的SQL_MODE设置为包含ONLY_FULL_GROUP_BY。
88. 如果没有通过ORDER BY子句显式地指定排序列，当查询使用GROUP BY子句的时候，结果集会自动按照分组的字段进行排序。如果不关心结果集的顺序，而这种默认排序有导致了需要文件排序，这可以使用OEDER_BY_NULL，让MySQL不再进行文件排序。也可以在GROUP BY子句中使用DESC或着ASC关键字，使分组的结果集按照需要的方向排序。
89. 分组查询的一个变种就是要去MySQL对返回的分组结果在做一次超级聚合。可以使用WITH ROLLUP子句来实现这种逻辑，最好的办法就是尽可能的将WITH ROLLUP功能转移到应用程序中处理。
90. 优化分页查询的一个最简单的办法就是尽可能地使用索引覆盖扫描，而不是查询所有的列。然后根据需要做一次关联返回所需的列。对于偏移量很大的时候，这样做的效率提升会非常大。
91. 延迟关联也可以将LIMIT查询转换成为已知位置大查询，让MySQL通过范围扫描获得对应的结果。
92. MySQL总是通过创建并填充临时表的方式来执行UNION查询。经常需要手工地将WHERE、LIMIT、ORDER BY等子句“下推”到UNION的各个子查询中，以便优化器可以充分利用这些条件进行优化。
93. 除非确实需要服务器消除重复的行，否则就一定要使用UNION ALL，如果没有ALL关键字，MyQL会给临时表加上DISTINCT选项，这会导致对整个临时表的数据做唯一性检查。这样做的代价非常高。即使有ALL关键字，MySQL仍然会使用临时表存储结果。事实上，MySQL总是将结果放入临时表，然后再读出，然后返回给客户端。
94. 在查询中混合使用过程和关系化逻辑的事哈，自定义变量可能会非常有用。
95. 用户自定义变量时一个用来存储内容的临时容器，在连接MySQL的整个过程中都存在。可以使用下面的SET和SELECT语句来定义它们，例：SET @one := 1;。
96. 自定义变量局限：
    1. 使用自定义变量的查询，无法使用查询缓存。
    2. 不能在使用常量或者表示服的地方是哟自定义变量。
    3. 用户自定义变量的生命周期是在一个连接中有效，所以不能用它们来做连接间的通信。
    4. 如果使用连接池或者持久化连接，自定义变量可能让看起来毫无关系的代码发生交互。
    5. 在5.0版本之前，是大小写敏感的，所以要注意代码在不同的MySQL版本间的兼容性。
    6. 不能显示地声明自定义变量的类型。确定未定义变量的具体类型的时机在不同MySQL版本中也可能不一样。
    7. MySQL优化器在偶像场景下可能会将这些变量优化掉，这可能导致代码不按预想的方式运行。
    8. 赋值的顺序和赋值的时间并不总是固定的，这依赖于优化器的决定。
    9. 赋值符号:=优先级非常低，所以需要注意，表达式应该使用明确的括号。
    10. 使用未定义变量不会产生任何语法错误。