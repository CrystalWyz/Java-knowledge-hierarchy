## 第四章 Schema与数据类型优化

1. 数据类型选择：

   1. 更小的通常更好：一般情况下，应该尽量使用可以正确存储数据的最小数据类型更小的数据类型通常更快，因为它们占用更小的磁盘、内存和CPU缓存，并且处理时需要的CPU周期也更少。
   2. 简单就好：简单的数据类型的操作通常需要更少的CPU周期。
   3. 尽量避免Null：如果查询中包含NULL的列，对MySQL来说更难优化，因为可为NULL的列使得索引、索引统计和值比较都更复杂。可为NULL的列会使用更多的内存空间，在MySQL里也需要特殊处理。当可为NULL的列被索引时，每个索引记录需要一个额外的字节，在MyISAM里甚至还可能导致固定大小的索引变成可变大小的索引。通常把可为NULL的列改为NOT NULL带来的性能提升比较小，如果计划在列上建索引，就应该尽量避免设计成可为NULL的列。（InnoDB使用单独的位（bit）存储NULL值，所以对于稀疏数据又很好的空间效率）

2. DATETIME和TIMESAMP列都可以存储相同类型的数据：时间和日期，精确到秒，然而TIMESTAMP只使用DATETIME一半的存储空间，并且会根据时区的变化，具有特殊的自动更新能力。另一方面，TIMESAMP允许的时间范围要小许多。

3. 有两种类型的数字：整数和实数。如果要存储整数，可以使用这几种整数类型：TINYINT、SAMLLINT、MEDIUMINT、INT、BIGINT。分别使用8、16、24、32、64位存储空间。它们可以存储的值范围从-2^N-1 ~ 

   (2^N-1) -1，其中N是存储空间的位数。

4. 整数类型有可选的UNSIGNED属性，表示不允许负值。

5. 整数计算一般使用64位的BIGINT整数，即使在32位环境也是如此。（一些聚合函数除外，它们使用DECIMAL或DOUBLE进行计算。）

6. MySQL可以为整数类型指定宽度，例如INT(11)，对大多数应用这是美没有义的：它不会限制值的合法使用，只是规定了MySQL的一些交互工具用来显示字符的个数。对于存储和计算来说，INT(1)和INT(11)是相同的。

7. 实数是带有小数部分的数字。它们不只是为了存储小数部分；也可以使用DECIMAL存储比BIGINT还大的整数。MySQL既支持精确类型，也支持不精确类型。FLOAT和DOUBLE类型支持使用标准的浮点运算进行近似计算。DECIMAL类似用于存储精确的小数。

8. 服务器自身实现了DECIMAL的高精度计算。相对而言，CPU直接支持原生浮点计算，所以浮点运算明显更快。

9. 对于DECIMAL列，可以指定小数点前后所允许的最大位数。MySQL5.0和更高版本将数字打包保存到一个二进制字符串中（每四个字节存9个数字），最多允许65个数字。

10. 浮点类型在存储同样范围的值时，通常比DECIMAL使用更少的空间。FLOAT使用4个字节存储，DOUBLE使用8个字节存储。相比FLOAT有更高和更大的范围。和整数类型一样，能选择的只是存储类型；MySQL使用DOUBLE作为内部浮点计算的类型。

11. 从MySQL4.1开始，每个字符串列可以定义自己的字符集和排序规则，或者说校对规则。

12. 存储引擎存储CHAR或者VARCHAR值的方式在内存中和在磁盘上可能不一样，所以MySQL方法区从存储引擎读出的值可能需要转换为另一种存储格式。

13. VARCHAR类型用于存储可变长字符串，时最常见的字符串数据类型。如果MySQL表使用ROW_FORMAT=FIXED创建的话，每一行都会使用定长存储。这样很浪费空间。

14. VARCHAR需要使用1或2个额外的字节记录字符串的长度：如果列的最大长度小于或等于255字节，则只使用一个字节表示，否则使用两个字节。

15. UPDATE时可能使行变得比原来更长。MyISAM会将行拆成不同的片段存储，InnoDB则需要分裂页来使行可以放进页内。

16. InnoDB可以把过长的VARCHAR存储为BLOB。

17. CHAR类型时定长的：MySQL总是更具定义的字符串长度分配足够的空间。当存储CHAR值时，MySQL会删除所有末尾的空格。CHAR值会根据需要采用空格进行填充的方式方便比较。

18. Memory引擎只支持定长的行，即使有变长字段也会根据最大长度分配最大空间。

19. BINARY和CARBINARY存储的是二进制字符串。二进制字符串根常规字符串非常相似，但是二进制字符存储的是字节码而不是字符。填充也不一样：MySQL填充BINARY采用的是\0而不是空格，在检索时也不会去掉填充值。

20. MySQL比较BINARY字符串时，每次按一个字节，并且根据该字节的数值进行比较。因此，二进制比较比字符比较简单很多，所以更快。

21. BLOB和TEXT都是为存储很大的数据而设计的字符串数据类型，分别采用二进制和字符串方式存储。

22. 字符类型是TINYTEXT、SMALLTEXT、TEXT、MEDIUMTEXT和LONGTEXT；对应的二进制类型是TINYBLOB、SMALLBLOB、BLOB、MEDIUMBLOB和LONGBLOB。BLOB是SMALLBLOB的同义词，TEXT时SMALLTEXT的同义词。

23. MySQL把每个BLOB和TEXT值当做一个独立的对象处理。存储引擎在存储时通常会做特殊处理。当BLOB和TEXT值太大时，InnoDB会使用专门的“外部”存储区域来进行存储，此时每个值在行内需要1～4个字节存储一个指针，然后在外部存储区域存储实际的值。

24. BLOB和TEXT家族之间仅有的不同时BLOB类型存储的是二进制数据，没有排序规则或字符集，而TEXT类型有字符集和排序规则。

25. MySQL对BLOB和TEXT列进行排序和其他类型是不同的：它只对每个列的最前max_sort_length字节而不是整个字符集做排序。如果只需要排序前面一小部分字符，则可以减少max_sort_length的配置，或者使用ORDER_BY_SUSTRING(column, length)。

26. MySQL不能将BLOB和TEXT列全部长度的字符串进行索引，也不能使用这些索引消除排序。

27. 因为Memory引擎不支持BLOB和TEXT类型，如果查询使用了BLOB或TEXT列并且需要使用隐式临时表，将不得不使用MyISAM磁盘临时表。

28. 又一个技巧时在所有用到BLOB字段的地方都适用SUBSTRING(column, length)将列值转换为字符串（在ORDER_BY子句中也适用），这样就可以使用内存临时表了。但是要确保截取的字符串足够短，不会使临时表的大小超过max_heap_table_size或tmp_table_size，超过一行同样会转换为临时表。

29. 如果EXPLAIN执行计划的Extra列包含“Using temporary”，则说明这个查询使用了隐式临时表。

30. 可以使用枚举列代替常用的字符串类型。枚举可以把一些不重复的字符串存储成一个预定义的集合。MySQL在存储枚举类型时非常紧凑，会根据列表值的数量压缩到一个或者两个字节中。MySQL在内部会将每个值在列表中的位置保存为整数，并且在表的.frm文件中保存“数字-字符串”映射关系的“查找表”。

31. 枚举字段时按照内部存储的整数而不是定义的字符串进行排序的。

32. 通用的设计实践：在“查找表”时采用整数主键而避免采用基于字符串的值进行关联。

33. 转成ENUM可以减少表的大小。

34. mySQL能存储的最小时间粒度为秒。但是MySQL也可以使用微秒级别的粒度进行临时运算。

35. DATETIME能保存大范围的值，从1001-9999年，精度为秒。它把日期和时间封装到格式为YYYYMMDDHHMMSS的整数中，与时区无关。使用8个字节的存储空间。

36. TIMESTAMP类型保存了从1970年1月1日午夜（格林尼治标准时间）以来的秒数，它和UNIX时间戳相同。只使用4分字节的存储空间，只能表示从1970-2038年。MySQL提供了FROM_UNIXTIME()函数把Unix时间戳转换为日期，并提供了UNIX_TIMESTAMP()函数把日期转换为Unix时间戳。

37. MySQL4.1以及更新版本按照DATETIME的方式格式化TIMESTAMP的值，TIMESTAMP显示的值也依赖于时区。

38. TIMESTAMP如果插入时没有指定第一个TIMESTAMP列的值，MySQL则设置这个列的值为当前时间。在插入一行记录时，MySQL默认也会更新第一个TIMESTAMP列的值。TIMESTAMP列默认为NOT NULL。

39. TIMESTAMP比DATETIME空间效率更高。

40. MySQL有少数几种存储类型使用紧凑的位存储数据。所有这些位类型，不管底层存储格式和处理方式如何，从技术上来说都是字符串类型。

41. BIT：可以使用BIT列在一列中存储一个或多个true\false值。BIT(1)定义一个包含单个位的字段，BIT(2)存储2位，以此类推，BIT列的最大长度是64位。

42. MyISAM会打包存储所有的BIT列，所以17个单独存储的BIT列只需要17位存储。其他存储引擎如Memory和InnoDB，为每个BIT列使用一个足够小的最小整数类型来存放。

43. MySQL把BIT当作字符串类型，而不是数字类型。当检索BIT(1)的值时，结果是一个包含二进制0或1值的字符串，而不是ASCII码的“0”或“1”。在数字上下文的场景中检索时，结果将是位字符串转换成的数字。

44. 如果需要保存很多true\false值，可以考虑合并这些列到一个SET数据类型，它在MySQL内部是以一系列打包到位的集合来表示的。无法在SET列上通过索引查找。

45. 为标识列选择数据类型时，应该选择根关联表中对呀列一样的类型。MySQL在内部使用整数存储ENUM和SET类型，然后在做比较操作时转换为字符串。

46. 对于标识列来说，ENUM和SET类型通常是一个糟糕的选择。

47. 应该避免使用字符串作为标识列，因为它们很消耗空间，并且通常比数字类型慢。MyISAM默认为字符串使用压缩索引，这会导致查询慢很多。对于完全“随机”的字符串也需要多加注意，会导致INSERT以及一些SELECT语句变得更慢：

    1. 因为插入值会随机地写到索引的不同位置，所以使得INSERT语句更慢，会导致页分裂、磁盘随机访问以及对于聚簇存储引擎产生聚簇索引碎片。
    2. SELECT语句会变得更慢，因为逻辑上相邻的行会分不在磁盘和内存的不同地方。
    3. 随机值导致缓存对所有类型的查询语句效果都很差，因为会使得查询缓存赖以工作的访问局部性原理失效。

48. 如果存储UUID值，应该移除“-”符号；或者更好的做法是：用UNHEX()转换UUID值为16字节的数字，并且存储在一个BINARY(16)列中。检索时可以通过HEX()函数来格式化为十六进制格式。

49. 应该用无符号整数存储IP地址。MySQL提供了INET_ATON()和INET_NTOA()函数在这两种表示方法之间的转换。

50. MySQL的存储引擎API工作时需要在服务器层和存储引擎层之间通过行缓冲格式拷贝数据，然后在服务器层将缓冲内容解码成各个列。从行缓冲中将编码过的列转换成行数据结构的操作代价时非常高的。MyISAM的定长行结构实际上与服务器层的行结构正好匹配，不需要转换。但MyISAM的变长行结构和InnoDB的行结构总是需要转换的。

51. MySQL限制了每个关联操作最多只能有61章表，如果希望查询执行得快速并且并发性好，单个查询最好在12个表以内做关联。

52. MySQL会在索引中存储NULL值，而Oracle不会。

53. 物化视图实际上是预先计算并且存储在磁盘上的表，可以通过各种各样的策略刷新和更新。

54. MySQL执行大部分修改表结构操作的方法是用新的结构创建一个空表，从旧表中查出所有数据插入新表，然后删除旧表。

55. ALTER TABLE允许使用ALTER COLUMN、MODIFY COLUMN和CHANGE COLUMN语句修改列。这三种操作都是不一样的。MODIFY COLUMN操作都将导致表重建。

56. 执行FLUSH TABLES WITH READ LOCK会关闭所有正在打开的表，并且禁止任何表被打开。

57. 未来高效地载入数据到MyISAM表中，又一个常用的技巧是先禁用索引（DISABLE KEYS）、载入数据，然后重新启用索引（ENABLE KEYS）。这个办法对唯一索引无效。