## 第03章 Kafka生产者

1. 除了内置的客户端外，Kafka还提供了二进制协议，也就是说，我们直接向Kafka网络端口发送适当的字节序列，就可以实现从Kafka读取消息或往Kafka写入消息。
2. 不同的场景对不同的消息有不同维度的要求。
3. ProducerRecord对象需要包含目标主题和要发送的内容，还可以指定键和分区。消息会被添加到一个记录批次里，这个批次里的所有消息会被发送到相同的主题和分区上。有一个独立的线程负责把这些记录批次发送到相应的broker上。
4. 服务器在受到这些消息时会返回一个响应。如果消息成功写入Kafka，就返回一个RecordMetaData对象，它包含了主题和分区信息，以及记录在分区里的偏移量。如果写入失败，则返回一个错误信息。生产者在受到错误之后会尝试重新发送消息，几次之后如果还失败，就返回错误信息。
5. Kafka生产者有三个必选属性：
   1. bootstrap.servers：指定broker的地址清单，地址的格式为host:port。清单里不需要包含所有的broker地址，生产者会从给定的broker里查找到其他broker的信息。
   2. key.serializer：设置键的序列化器。告诉生产者如何把这些Java对象转换成字节数组。注意，key.serializer是必须设置的，就算你打算只发送值内容。
   3. value.serializer：指定值的序列化器。
6. 发送消息的3种方式：
   1. 发送并忘记：把消息发送给服务器，但不关心它是否正常到达。大多数情况下，消息会正常到达，因为Kafka是高可用的，而且生产者会自动尝试重发。不过，使用这种方式有时候也会丢失一些数据。
   2. 同步发送：我们使用send()方法发送消息，他会返回一个Future对象，调用get()方法进行等待，就可以知道消息是否发送成功。
   3. 异步发送：我们调用send()方法，并指定一个回调函数，服务器在返回响应时调用该函数。
7. 生产者的send()方法将ProducerRecord对象作为参数，消息会先被放到缓冲区，然后使用单独的线程发送到服务器端。
8. 同步发送：producer.send()方法先返回一个Future对象，然后调用Future对象的get()方法等待Kafka响应。KafkaProcedure一般会发生两类错误。其中一类是可重试错误，这类错误可以通过重发消息来解决，另一类错误是不可重试错误，直接抛出异常。
9. 异步发送：实现Kafka的Callback接口，然后在调用send()方法时提供该回调函数。
10. 生产者配置：
    1. acks：指定了必须要有多少个分区副本收到消息，生产者才会认为消息写入是成功的。
    2. buffer.memory：设置生产者内存缓冲区的大小，生产者用它缓冲将要发送到服务器的消息。
    3. compression.type：默认情况下，消息发送时不会被压缩。该参数可以设置为snappy、gzip或lz4.指定了消息被发送给broker之前使用哪一种压缩算法进行压缩。snappy算法由google发明，它占用较少的CPU，却能提供较好的性能和相当可观的压缩比，如果比较关注性能和网络带宽，可以使用这种算法。gzip压缩算法一般会占用较多的CPU，但会提供更高的压缩比，所以如果网络带宽比较有限，可以使用这种算法。
    4. retries：决定了生产者可以重发消息的次数，如果达到这个次数，生产者会放弃重试并返回错误。默认情况下，生产者会在每次重试之间等待100ms，不过可以通过retry.backoff.ms参数来改变这个时间间隔。
    5. batch.size：当有多个消息要被发送到同一分区时，生产者会把它们放在同一个批次里。该参数指定了一个批次可以使用的内存大小，按照字节数来计算。
    6. linger.ms：指定了生产者在发送批次之前等待更多消息加入批次的时间。KafkaProcedure会在批次填满或linger.ms达到上限时把批次发送出去。
    7. client.id：可用是任意的字符串，服务器会用它来识别消息的来源，还可以用在日志和配额指标里。
    8. max.in.flight.requests.per.connection：指定了生产者在收到服务器响应之前可以发送多少消息。把它设置为1可以保证消息是按照发送的顺序写入服务器的。
    9. timeout.ms、request.timeout.ms和metadata.fetch.timeout.ms：request.timeout.ms指定了生产者在发送数据时等待服务器返回响应的时间，metadata.fetch.timeout.ms指定了生产者在获取元数据（比如目标分区的首领是谁）时等待服务器返回响应的时间。timeout.ms指定了broker等待同步副本返回消息确认的时间。
    10. max.block.ms：指定了在调用send()方法或使用partitionsFor()方法获取元数据时生产者的阻塞时间。
    11. max.request.size：控制生产者发送的请求大小，能发送的单个消息的最大值，也可以指单个请求里所有消息总的大小。
    12. receive.buffer.bytes和send.buffer.bytes：分别指定了TCP socket接收和发送数据包的缓冲区大小。如果它们被设置为-1，就使用操作系统的默认值。
11. 键有两个用途：可以作为消息的附加信息，也可以用来决定消息该被写道主题的哪个分区。拥有相同键的消息将被写到同一个分区。如果键值为null，并使用了默认的分区器，那么纪录将被随机地发送到主题内各个可用的分区上。分区器使用轮询算法将消息均衡地分布到各个分区上。
12. 如果键不为空，并且使用了默认的分区器，那么Kafka会对键进行散列（使用Kafka自己的散列算法，即使升级Java版本，散列值也不会发生变化），然后根据散列值把消息映射到特定的分区上。
13. 只有在不改变主题分区数量的情况下，键与分区的映射才能保持不变。