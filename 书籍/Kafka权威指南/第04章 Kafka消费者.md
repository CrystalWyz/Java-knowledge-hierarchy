## 第04章 Kafka消费者

1. Kafka消费者属于消费者群组。一个群组里的消费者订阅的是同一个主题，每个消费者接受主题的一部分分区的消息。（核心：一个分区只能被一个消费者消费，一个消费者可用消费多个分区。）不要让消费者的数量超过主题分区的数量，多余的消费者只会被闲置）
2. 只要保证每个应用程序有自己的消费者群组，就可以让它们获取到主题的所有信息。（可以将消费者群组视为一个真正的消费单位）
3. 分区的所有权从一个消费者转移到另一个消费者，这样的行为被称为再均衡。在再均衡期间，消费者无法读取消息，造成整个数组一小段时间的不可用。当分区被重新分配给另一个消费者时，消费者当前的读取状态会丢失。
4. 消费者通过向被指派为群组协调器的broker（不同的群组可以有不同的协调器）发送心跳包来维持他们和群组的从属关系以及它们对分区的所有权关系。消费者会在轮询消息或提交偏移量时发送心跳。如果消费者停止发送心跳的时间足够长，会话就过期了，群组协调器认为它已经死亡，就会触发一次再均衡。
5. 如果一个消费者发生崩溃，并停止读取消息，群组协调器会等待几秒钟，确认它死亡了才会触发再均衡。在清理消费者时，消费者会通知协调器它将要离开群组，协调器会立即触发一次再均衡，尽量降低处理停顿。
6. 如果你使用的是较新版本的Kafka，并且需要处理耗费较长时间的消息，只需加大max.poll.interval.ms的值来增加轮询时间间隔的时常。
7. 当消费者要加入群组时，它会向群组协调器发送一个JoinGroup请求。第一个加入群组的消费者将成为“群主”。群主从协调器那获取群组的成员列表并负责给每一个消费者分配分区。它使用了一个实现了PartitionAssignor接口的类来决定哪些分区应该被分配给哪个消费者。每个消费者只能看到自己的分配信息，只有群主知道群主里所有消费者的分配信息。
8. 使用subscribe()方法接受一个主题列表作为参数来订阅主题。也可以在调用subscribe()方法时传入一个正则表达式。正则表达式可以匹配多个主题，如果有人创建了新的主题，并且主题的名字与正则表达式相匹配，那么会立即触发一次再均衡，消费者就可以读取新添加的主题。
9. 在第一次调用新消费者的poll()方法时，他会负责查找GroupCoordinator，然后加入群组，接受分配的分区。如果发生了再均衡，整个过程也是在轮询期间进行的。
10. 在同一个群组里，我们无法让一个线程运行多个消费者，也无法让多个线程安全地共享一个消费者。
11. 消费者配置：
    1. fetch.min.bytes：指定了消费者从服务器获取记录的最小字节数。broker在受到消费者的数据请求时，如果可用的数据量小于fetch.min.bytes指定的大小，那么它会等到有足够的可用数据时才把它返回给消费者。
    2. fetch.max.wait.ms：指定broker的等待时间，默认是500ms。
    3. max.partition.fetch.bytes：指定了服务器从每个分区里返回给消费者的最大字节数。默认值是1MB。max.partition.fetch.bytes的值必须比broker能够接受的最大消息的字节数大，否则消费者可能无法读取这些消息。
    4. session.timeout.ms：指定了消费者在被认为死亡之前可用与服务器断开连接的时间，默认是3s，heartbeat.interval.ms指定了poll()方法向协调器发送心跳的频率，一般是session.timeout.ms的三分之一
    5. auto.offset.reset：指定了消费者在读取一个没有偏移量的分区或者偏移量无效的情况下该如何处理，默认值是lastest，意思是在偏移量无效的情况下，消费者将从最新的记录开始读取数据，另一个值是earliest，在偏移量无效的情况下，消费者将从起始位置读取分区消息。
    6. enable.auto.commit：指定了消费者是否自动提交偏移量，默认值是true。还可以通过配置auto.commit.interval.ms属性来控制提交的频率。
    7. partition.assignment.strategy：分配策略。分配是在主题内独立完成的。
       1. Range：默认，把主题的若干个连续的分区分配给消费值，会造成分配不均的问题。
       2. RoundRobin：轮询分配，会给所有消费者分配相同数量的分区（最多差一个分区的数量）
    8. client.id：可以是任意字符串，broker用它来标识从客户端发送过来的消息。
    9. max.poll.records：用于控制单次调用call()方法能够返回的记录数量。
    10. receive.buffer.bytes与send.buffer.bytes：TCP缓冲区的大小。
12. 把更新分区当前位置的操作叫**提交**。消费者往一个叫做_consumer_offset的特殊主题发送消息，消息里包含每个分区的偏移量。如果消费者一直处于运行状态，那么偏移量就没有什么用处。不过，如果消费者发生崩溃或者有新的消费者加入群组，就会触发再均衡，完成再均衡之后，每个消费者可能分配到新的分区，而不是之前处理的那个。为了能够继续之前的工作，消费者需要读取每个分区最后一次提交的偏移量，然后从偏移量指定的地方继续处理。
13. 如果提交的偏移量小于客户端处理的最后一个消息的偏移量，那么处理两个偏移量之间的消息就会被重复处理。如果提交的偏移量大于客户端处理的最后一个消息的偏移量，那么处理两国偏移量之间的消息将会丢失。
14. 与消费者里的其他东西一样，自动调节也是在轮询里进行的。消费者每次在进行轮询时会检查是否该提交偏移量了，如果是，那么就会提交从上一次轮询返回的偏移量。在使用自动提交时，每次调用轮询方法都会把上一次调用返回的偏移量提交上去（在close()方法调用的时候也会进行自动提交）
15. 使用commitSync()同步提交偏移量是最简单也最可靠的。这个API会提交由poll()返回的最新偏移量，提交成功后马上返回，如果提交失败就会抛出异常（只要没发生不可恢复的错误，commitSync()方法会一直尝试直至成功）
16. 手动提交有一个不足之处，在broker对提交请求作出回应之前，应用程序会一直阻塞。可以在commitASync()传入回调函数，在broker作出响应时会执行回调进行异步提交。
17. 发送在关闭消费者或再均衡之前的最后一次提交，要确保一定提交成功。
18. 消费者API允许再调用commitSync()和commitASync()方法时传进去希望提交的分区的偏移量map。
19. 在为消费者分配新分区或移除旧分区时，可以通过消费者API执行一些应用程序代码，在调用subscribe()方法时穿进去一个ConsumerRebalanceListener实例就可以了。两个需要实现的方法：
    1. onPartitionsRevoked()方法会在再均衡开始之前和消费值停止读取消息之后被调用。如果在这里提交偏移量，下一个接管分区的消费者就知道从哪里开始读取了。
    2. onPartitionsAssigned()方法会在重新分配分区之后和消费者开始读取消息之前被调用。
20. 要注意，提交的是最近处理过的消息偏移量，而不是批次中还在处理的最后一个偏移量。因为分区有可能在我们还在处理消息的时候被撤回。我们要提交所有分区的偏移里，而不只是哪些即将失去所有权分区的偏移量。
21. 如果你想从分区的起始位置开始读取消息，或者直接跳到分区的末尾开始读取消息，可以使用seekToBeginning()和seekToEnd()
22. 在消费者启动或分配到新的分区时，可以使用seek()方法查找保存在数据库里的偏移量。
23. 在消费者启动或分配到新的分区时，可以使用seek()方法查找保存在数据库里的偏移量。
24. 消费者如果要确定退出循环，需要通过另一个线程调用consumer.wakeup()方法。如果循环运行在一个主线程里，可以在ShutdownHook里调用该方法。consumer.wakeup()是消费者唯一一个可以从其他线程里安全调用的方法。调用consumer.wakeup()可以退出poll()，并抛出WakeupException异常，或者如果调用consumer.wakeup()时线程没有等待轮询，那么异常将在下一轮调用poll()时抛出。在推出线程之前调用consumer.close()是很有必要的，它会提交任何还没有提交的东西，并向群组协调器发送消息，告知自己要离开群组，接下来就会触发再均衡，而不需要等待会话超时。
25. 只需要一个消费者从一个主题的所有分区或者莫个特定的分区读取数据，就不需要订阅主题，取而代之的是为自己分配分区。一个消费者可以订阅主题（并表示加入消费者群组），或者为自己分配分区，但不能同时做两件事情（assign()方法）如果主题新增加了分区，消费者并不会收到通知。