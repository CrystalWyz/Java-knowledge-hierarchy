## 第二章 示例研究

1. 在设计中，存在许多彼此矛盾的限制条件，应仔细考虑与权衡。
2. 层次结构信息的标识通常时通过一种称为递归组合（子结构嵌套子结构）的技术来实现的。地柜组合可以由较简单的元素逐渐建立复杂的元素，是我们通过简单图形元素构造文档的方法之一。
3. 通过接口可以实现兼容的看待不同的类。
4. 图元：最小组成单元。我们将为出现在文档结构中的所有对象定义一个抽象类Glyph（图元）。它的子类既定义了基本的图形元素，又定义了结构元素。
5. 图元有三个基本责任：1、怎样画出自己；2、它们占用多大空间；3、它们的父图元和子图元是什么。
6. 父图元通常需要知道子图元需要占用多大的空间，以把它和其他图元安排在一行上，保证不会相互覆盖。
7. 递归组合不仅可以用来表示文档，还可以用来表示任何复杂的、层次式的结构。Composite模式描述了面向对象的递归组合的本质。
8. 在对象中封装算法是Strategy模式的目的，模式的主要参与者是Strategy对象（这些对象中封装了不同的算法）和它们的操作环境。Strategy模式应用的关键点在于为Strategy和它的环境设计足够通用的接口以支持一系列算法。
9. 在Decorator模式中，修饰指给一个对象增加职责的事物。
10. 窗口组件是关于用户界面上作为控制元素的按钮、滚动条和菜单等可视图元的另一个术语。
11. 工厂创造了产品对象。更进一步，工厂生产的产品是彼此相关的。 每一个具体的工厂生产一系列产品。
12. 工厂和产品是Abstract Factory模式的主要参与者。该模式描述了怎样在不直接实例化类的情况创建一系列相关的产品对象。他最适用于产品对象的树木和种类不变，二聚体产品系列之间存在不同的情况。抽象工厂模式对产品系列的强调，使它区别于其他只与一种产品对象有关的创建形模式。
13. 一个平台的窗口系统将多个互相重叠的窗口展示在一个点阵显示其上。它管理屏幕空间和键盘、鼠标到窗口的输入通道。
14. Abstract Factory工作依赖于公共的抽象类。
15. 模式精髓：对变化的概念进行封装。
16. Bridge模式的目的就是允许分离的类层次一起工作，即使它们是独立演化的。
17. 如果用户多次重复无意义的字体改变操作，他应该不比执行相同数目的撤回操作才可以返回到上一次有意义的操作。
18. Command模式描述了怎样封装请求，也描述了一致的发送请求的接口。
19. Iterator模式描述了那些支持访问和便利对象结构的技术，它不仅可用于组合结构，也可用于集合。该模式抽象了遍历算法，对客户隐藏了它所遍历对象的内部结构。
20. 术语访问者泛指在便利过程中“访问”被便利对象并做适当操作的一类对象。
21. Visitor模式：Visitor模式及其子类是该模式的主要参与者。Visitor模式描述了允许对图元结构的分析数目不受限制地增加而不必改变图元类本身。另一个优点就是它不局限于像图元结构这样的组合者，也适用于其他任何对象结构。
22. 在使用Visitor模式之前你要问自己的一个重要问题是：哪一个类层次变化得最厉害？该模式最适合于当你想对一个稳定类结构的对象做许多种不同的事情的情况。