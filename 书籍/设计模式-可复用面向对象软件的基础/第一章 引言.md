## 第一章 引言

1. 设计应该对手头的问题有针对性，同时对将来的问题和需求也要有足够的通用性。

2. 一般而言，一个模式有四个基本要素：

   1. 模式名：一个助记名，他用一两个词来描述模式的问题、解决方案和效果。
   2. 问题：描述了应该在何时使用模式。他解释了设计问题和问题存在的前因后果。有时候，问题部分会包括使用模式必须满足的一系列先决条件。
   3. 解决方案：描述了设计的组成成分、它们之间的相互关系及各自的职责和协作方式。
   4. 效果：描述了模式应用的效果及使用模式应该权衡的问题。对于评价设计选择和理解使用模式的代价及好处具有重要意义。包括它对系统的灵活性、扩充性或可移植性的影响。

   设计模式确定了所包含的类和实例，它们的角色、协作方式以及职责分配。

3. MVC包括三类对象。模型（Model）是应用对象，视图（View）是它在屏幕上的表示。控制器（Controller）定义用户界面对用户输入的响应方式。

4. MVC通过建立一个“订阅/通知”协议来分离视图和模型。视图必须保证它的显示正确地反映了模型的状态。一旦模型的数据发生编号，模型将通知有关的视图，每个试图相应地得到刷新自己的机会。

5. 将对象分离，使得一个对象的改变能够影响另一个对象，而这个对象并不在需要知道那些被影响的对象的细节。这个更一般的设计被描述成Observer模式。

6. 将一些对象划为一组，并将该组对象当作一个对象来使用。这个设计被描述为Composite模式。

7. Strategy模式（使用不同的子类实现不同的策略）：一个策略是一个表述算法的对象。当你想静态或动态地替换一个算法，或你有很多不同的算法，或算法中包含你想要封装的复杂数据结构时，策略模式非常有用。

8. MVC的主要关系还是由Observer、Composite和Strategy三个设计模式给出的。

9. 设计模式编目：

   1. Abstract Factory：提供一个创建一系列相关或相互依赖对象的接口，而无需指定它们具体的类。
   2. Adapter：将一个类的接口转换成客户希望的另外一个接口。Adapter模式使得原本由于接口不兼容而不能一起工作的那些类可以一起工作了。
   3. Bridge：将抽象部分与它的实现部分分离，使它们都可以独立地变化。
   4. Builder：将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示。
   5. Chain of Responsibility：解除请求的发送者和接收者之间的耦合，使多个对象都有机会处理这个请求。将这些对象连成一条链，并沿着这条链传递该请求，直到有一个对象处理它。
   6. Command：将一个请求封装成一个对象，从而使你可用不同的请求对客户进行参数化；对请求排队或记录请求日志，以及支持可取消的操作。
   7. Composite：将对象组合成树形结构以表示“部分——整体”的层次结构。Composite使得客户对单个对象和组合对象的使用具有一致性。
   8. Decorator：动态地给一个对象添加一些额外的职责。就扩展功能而言，Decorator模式比生成子类的方式更灵活。
   9. Facade：为子系统中的一组接口提供一个一致的界面，Facade模式定义了一个高层接口，这个接口使得这一子系统更加容易使用。
   10. Factory Method：定义一个用于创建对象的接口，让子类决定将哪一个类实例化。使一个类的实例化延迟到其子类。
   11. Flyweight：运用共享技术有效地支持大量细粒度的对象。
   12. Interpreter：给定一个语音，定义它的文法的一种表示，并定义一个解释器，该解释器使用改表示来解释语言中的句子。
   13. Iterator：提供一种方法顺序访问一个聚合对象中的各个元素，而又不需要暴露对象的内部表示。
   14. Mediator：用一个中介对象来封装一系列的对象交互。中介者使各对象不需要显示地相互引用，从而使其耦合松散，而且可以独立地改变它们之间的交互。
   15. Memento：在不破坏封装性的前提下，捕获一个对象的内部表态，并在该对象之外保存这个状态。这样以后就可将该对象恢复到保存状态。
   16. Observer：定义对象间的一种一对多的依赖关系，以便当一个对象的状态发生改变时，所有依赖于它的对象都得到通知并且刷新。
   17. Prototype：用原型实例指定创建对象的种类，并且通过拷贝这个原型来创建新的对象。
   18. Proxy：为其他对象提供一个代理以控制对这个对象的访问。
   19. Singleton：保证一个类仅有一个实例，并提供一个访问他的全局访问点。
   20. State：允许一个对象在其内部状态改变时改变它的行为。对象看起来似乎修改了它的所属类。
   21. Strategy：定义一系列的算法，把它们一个个封装起来，并且使它们可相互替换。本模式使得算法的编号可独立与使用它的客户。
   22. Template Method：定义一个操作中的算法的骨架，而将一些步骤延迟到子类中。使得子类不改变一个算法的结构即可重定义该算法的某些特定步骤。
   23. Visitor：表示一个作用于某对象结构中的各元素的操作。它使你可以在不改变各元素的类的前提下定义作用于这些元素的新操作。
   
10. 模式依据其目的可以分为创建型、结构型和行为型三种。创建型模式与对象的创建有关；结构型模式处理类或对象的组合，行为型模式对类或对象怎样交互和怎样分配职责进行描述。

11. 类模式处理类和子类之间的关系，这些关系通过继承建立，是静态的，在编译时便确定下来了。对象模式处理对象间的关系，这些关系在运行时是可以变化的，更具动态性。

12. 创建型类模式将对象的部分创建工作延迟到子类，而创建型对象模式则将它延迟到另一个对象中。结构型类模式使用继承机制来组合类，而结构型对象模式则描述了对象的组装方式。行为型类模式使用继承描述算法和控制流，而行为对象模式则描述了一组对象怎样写作完成单个对象所无法完成的任务。

13. 对象包括数据和对数据进行操作的过程，过程通常称为方法或操作。客户请求是使对象执行操作的唯一方法，操作又是对象改变内部数据的唯一方法。对象的内部状态是被封装的，它不能直接访问，它的表示对于对象外部是不可见的。

14. 对象声明的每一个操作指定操作名、作为参数的对象和返回值，这就是所谓的操作的型构。对象操作所定义的所有操作型构的集合被成为该对象的接口。对象接口描述了该对象所能接收的全部请求的集合，任何匹配对象接口中型构的请求都可以发送给该对象。

15. 类型是一个用来标识特定接口的名字。如果一个对象接受“Window”接口所定义的所有操作请求，那么我们就说该对象具有“Window”类型。一个对象可以有许多类型，并且不同的对象可以共享同一个类型。

16. 接口可以包含其他接口作为子集。当一个类型的接口包含另一个类型的接口时，我们就说它时另一个类型的子类型，而称另一个类型为它的超类型。常说子类型继承了它的超类型的接口。

17. 对象接口与其功能实现时相分离的，不同对象可以对请求做不同的实现，也就是说，两个又相同接口的对象可以有完全不同的实现。

18. 当给对象发送请求时，所引起的具体操作既与请求本身有关又与接受对象有关。发送给对象的请求和它的相应操作在运行时可以有完全不同的实现。

19. 当给对象发送请求时，锁引起的具体操作既与请求本身有关又与接收对象有关。发送给对象的请求和它的相应操作在运行时的连接就称为动态绑定。动态绑定允许你再运行时彼此替换有相同接口的对象。这种可替换性称为多态。

20. 对象通过实例化类来创建，此对象被称为该类的实例。

21. 新的类可以由已存在的类通过类继承来定义。当子类继承父类时，子类包含了父类定义的所有数据和操作。

22. 抽象类的主要目的时为它的子类定义公共接口。抽象类将把它的部分或全部操作的实现延迟到子类中，因此，抽象类不能被实例化。再抽象类中定义却没有实现的操作被称为抽象操作。非抽象类称为具体类。

23. 子类能够重定义父类定义的操作。

24. 混入类是给其他类提供可选择的接口或功能的类。它与抽象类一样不能实例化。混入类要求多继承。

25. 对象的类定义了对象是怎样实现的，同时也定义了对象的内部状态和操作的实现。但是对象的类型只与它的接口有关，接口即对象能响应的请求的集合。一个对象可以有多个类型，不同类的对象可以有相同的类型。

26. 对象的类和类型是有紧密联系的。因为类定义了对象所能执行的操作，也定义了对象的类型。当我们说一个对象是一个类的实例时，即指该对象支持类所定义的接口。

27. 类继承根据一个对象的实现定义了另一个对象的实现。接口继承描述了一个对象什么时候能被用来替代另一个对象。

28. 可复用的面向对象设计原则：

    1. 针对接口编程，而不是针对实现编程：不将变量声明为某个特定的具体类的实例对象，而是让它遵从抽象类所定义的接口。
    2. 优先使用对象组合，而不是类继承：对象组合是通过获得对其他对象的引用而在运行时动态定义的。组合要求对象遵循彼此的接口约定。

29. 通过生成子类的复用通常被称为白箱复用。术语“白箱”时相对可视性而言的：再继承的方式中，父类的内部细节对子类可见。

30. 对象组合是类继承之外的另一种复用选择。新的更复杂的功能可用通过组装或组合对象来获得。对象组合要求被组合的对象具有良好定义的接口。这种复用风格被称为黑箱复用，因为对象的内部细节是不可见的。对象只以“黑箱”的形式出现。

31. 委托是一种组合方法，它使组合对象具有与继承同样的复用能力。在委托方式下，有两个对象参与处理一个请求，接受请求的对象将操作委托给它的代理者。类似于子类将请求交给它的父类处理。

    缺点：动态的、高度参数化的软件比静态软件更难以理解。运行低效。

32. 另一种功能复用技术是参数化类型（类似于Java泛型），也是类属或模板。

33. 一个面向对象程序运行时的结构通常与它的代码结构相差较大。代码结构在编译时就被确定下来了，它由继承关系固定的类组成。而程序的运行时结构式由快速变化的通信对象网络组成的。两个结构彼此独立。

34. 聚合意味着一个对象拥有另一个对象或对另一个对象负责。一般我们称一个对象包含另一个对象或者是另一个对象的一部分。聚合意味着聚合对象和其所有者具有相同的生命周期。

35. 相识意味着一个对象仅仅知道另一个对象。有时相识也被称为“关联”或“引用”关系。相识的对象可能请求彼此的操作，但是它们不为对方负责。相识是一种比聚合要弱的关系，它只标识了对象间较松散的耦合关系。

36. 框架是构成一类特定软件的可复用设计的一组相互协作的类。框架规定了你的应用的体系结构。它定义了整体结构，类和对象的划分，各部分的主要责任，类和对象怎么协作，以及控制流程。框架对应用的主要贡献在于它所定义的体系结构。

37. 模式和框架的区别

    1. 模式设计比框架更抽象。
    2. 设计模式比框架更小的体系结构。
    3. 框架比设计模式更加特例化。