## 第三章 垃圾收集器与内存分配策略

1. 程序计数器、虚拟机栈、本地方法栈随线程而生，随线程而灭。

2. 栈中的栈帧随着方法的进入和退出执行着入栈与出栈。

3. 对于程序计数器、虚拟机栈、本地方法栈来说，内存分配与回收都具备确定性，当方法或线程结束，内存自然回收。

4. Java堆与方法区具有显著的不确定性，内存的分配与回收是动态的，是垃圾收集器的重点关注对象。

5. 引用计数法。

6. Java的内存管理子系统通过可达性分析算法来判断。

7. （JDK1.2之前）引用的传统定义：如果reference类型的数据中存储的是一块内存的起始地址，则为引用。

8. JDK1.2之后，引用分为：强引用、软引用、弱引用、虚引用。

   ​	强引用：即传统引用，永不回收。

   ​	软引用：描述一些还有用，但非必需的对象，如缓存。在内存将溢出之前回收，若仍溢出则抛出异常。

   ​	弱引用：也描述那些非必需对象，只能生存到下一次垃圾收集发生为止。

   ​	虚引用：完全不影响对象生命，也无法通过其访问对象实例，唯一的目的只是为了在这个对象被回收时，						收到一个系统通知。

9. 判断对象死亡，两次标记：

   1. 可达性分析：没有与GC Roots相连的引用链，标记一次。
   2. finalize()方法：没有重写 or 已被调用（最多只调用一次），标记一次。

10. 若这个对象被判定为有必要执行finalize()方法，将被放置在一个F-Queue的队列中，被一条低优先级的Finalizer线程调用，但并不承诺一定等待它运行结束（防止回收子系统崩溃）

11. 任何一个对象的finalize()方法都只会被调用一次。

12. 判定一个类是否“不再使用”：

    1. 该类的所有实例都已被回收（包括派生子类的实例）
    2. 类加载器被回收。
    3. 该类对应的java.lang.Class对象无引用，无法通过反射访问该类的方法。

13. 垃圾收集器算法可分为两大类：

    1. 引用计数式垃圾收集，又称直接垃圾收集器。
    2. 追踪式垃圾收集，又称间接垃圾收集。

14. 分代收集理论：

    1. 弱分代假说：绝大多数对象都是朝生夕灭的。
    2. 强分代假说：熬过越多次垃圾收集的对象越难以消亡。
    3. 跨代引用假说：跨代引用相对于同代引用来说仅占极为少数。

15. HotSpot将Java堆划分为新时代和老年代。

16. 记忆集：把老年代划分为若干小块，标识出哪一块会存在跨代引用。

17. “标记-清理”算法，最早出现也是最基础的算法，执行效率不稳定，内存空间碎片化。

18. “标记-复制”算法解决了存在大量可回收对象的效率问题，但空间浪费太大，改进版“Appel式回收”被HotSpot采用于新时代。

19. “标记-整理”算法结合“标记-清理”算法与老年代特征而来。

20. 可作为GC Root的节点主要在全局性的引用与执行上下文。

21. 所有收集器在根节点枚举时都必需暂停用户线程，面临相似的“Stop The World”的困扰。

22. 可达性分析算法耗时最长的查找引用链的过程已经可以做到与用户线程一起并发。

23. 目前主流的Java虚拟机使用的都是准确式垃圾收集，有办法直接得到哪些地方存在着对象的引用。

24. 在HotSpot的解决方案里，使用一组称为OopMap的数据结构。

25. 一旦类加载动作完成，HotSpot就会把对象内什么偏移量上是什么类型的数据计算出，在即时编译的过程中，也会在特定的位置记录下栈里和寄存器里哪些位置是引用。

26. HotSpot没有为每条指令都生成OopMap，只是在“特定的位置”记录了这些信息，这些位置被称为安全点。

27. 安全点位置的选取基本上是以“是否具有让程序长时间执行的特征”为标准进行选定的，因为每条指令执行时间都非常短暂，程序不太可能因为指令流长度太长这样的原因而长时间执行，“长时间执行”最明显的特征就是指令序列的复用。

28. HotSpot使用内存保护陷阱的方式，把轮询操作精简至只有一条汇编指令的程度。

29. 安全点机制保证了程序执行时，在不太长的时间内就会遇到可进入垃圾收集过程的安全点。

30. 安全区域时指能够确保在某一段代码片段之中，引用关系不会发生变化，因此，在这个区域中任意地方开始垃圾收集都是安全的。

31. 卡表就是记忆集的一种具体实现，它定义了记忆集的记录精度、与堆内存的映射关系等。

32. 字节数组CARD_TABLE等每一个元素都对应着其标识的内存区域中一块特定大小的内存块，这个内存块称作“卡页”。一般来说，卡页大小都是以2的N次幂的字节数。

33. 在HotSpot虚拟机时通过写屏障技术维护卡表状态的。

34. 赋值的前后都在写屏障的覆盖范围内。在赋值前的部分叫做写前屏障，在赋值后的则叫做写后屏障。

35. 现代中央处理器的缓存系统中是以缓存行为单位存储的，当多线程修改相互独立的变量时，如果这些变量恰好哦、共享一个缓存行，就会彼此影响（写回、无效化或者同步）二导致性能降低——伪共享。

36. 虚拟机的记录操作都是通过写屏障实现的。CMS是基于增量更新来做并发标记的，G1、Shenandoah则是用原始快照来实现的。