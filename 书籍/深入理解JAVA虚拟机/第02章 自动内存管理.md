## 第二章 自动内存管理

1. 虚拟机有自动内存管理机制，对Java程序员来说不易出现内存泄漏与内存溢出。

2. Java虚拟机将内存划分为：方法区、虚拟机栈、本地方法栈、堆、程序计数器。

3. 程序计数器是一块较小的内存空间，它可以看作是当前线程所执行的字节码的行号指示器。

4. Java虚拟机的多线程数通过线程轮流切换、分配处理器执行时间的方法实现，每条线程都需要有一个独立的程序计数器。

5. Java虚拟机也是线程私有，生命周期与线程相同，秒速线程内方法的执行：每个方法被执行，则创建一个栈帧，保持方法的有关信息，直到方法结束而弹栈。

6. 在Java中，“栈内存”通常指虚拟机栈（中的局部变量表）

7. 局部变量表中存放基本数据类型、对象引用、returnAddress类型，以局部变量槽来表示，只有long与double占两个槽。

8. 本地方法栈管理虚拟机使用的native方法。

9. HotSpot将虚拟机栈与本地方法栈合并了。

10. Java堆数虚拟机锁管理的最大一块内存，被所有线程共享，虚拟机启动时创建，存放对象实例，是垃圾收集器管理的内存区域。

11. 现代垃圾收集器大部分都是基于分代收集算法。

12. Java堆可以处于物理上不连续的内存空间，但在逻辑上应被视为连续的，可是固定大小，也可以是可扩展的。

13. 方法区也是各线程共享区域，它用于存储已被虚拟机加载的类型信息、常量、精通变量、即时编译器编译后的代码缓存等数据。

14. 在JDK1.8以前，HotSpot使用永久代实现方法区，在JDK1.8时改用元空间。

15. 运行时常量池上方法区等一部分（JDK6），具有动态性。

16. 虚拟机分配内存有指针碰撞与空闲指针两种方法。

    并发时：

    	1. 对分配内存进行同步处理。
     	2. 使用本地线程分配缓冲（TLAB）将不同线程划分在不同空间。

17. 内存分配完后初始化为0，保证实例对象自动可以不赋值就能使用。

18. Java创建对象的过程：

    ​	类加载检查 -> 内存分配 -> 对象头设置 -> <init>()方法

19. 在HotSpot虚拟机中，对象在堆中三部分：对象头、实例数据、对其填充。

20. 在HotSpot虚拟机中，对象头包含两部分：

     1. 存储对象运行时数据

     2. 类型指针：指向它的类型元素据指针（即哪个类的实例）

        （如果是Java数组，对象头头中还包含数组长度）

21. 实例数据是对象真正存储的有效信息，即代码中定义的字段内容。

22. HotSpot的自动内存管理要求对象起始地址必须是8字节的整数倍，所需要对其填充将实例数据块大小补全。

23. 虚拟机定位对象的方式：句柄与直接指针。

24. 句柄：在Java堆中划分一块句柄池，句柄包含了对象实例数据与类型数据地址。

    优势：栈中存储稳定的句柄地址，对象移动时只需要改变句柄池中的实例指针。

25. 直接指针访问对象速度更快.（节省一次指针定位时间的开销）

26. 除了程序计数器外，虚拟机的其他内存区域都能发生OutOfMemoryError

27. 出现Java堆内存溢出时，异常堆栈信息“Java.lang.OutOfMemory”会进一步提示"Java heap space"。

28. 自JDK7起，运行时常量池被移至Java堆中。

29. 若出现“Java.lang.OutOfMemory”后跟“PermGen space”代表方法区内存溢出。